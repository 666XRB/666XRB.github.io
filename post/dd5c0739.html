<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>树和二叉树 | cout&lt;&lt;&quot;金缕衣&quot;;</title><meta name="author" content="下完这场雨"><meta name="copyright" content="下完这场雨"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="树和二叉树数据的逻辑结构     线性结构：一对一 非线性结构：一对多，多对多  树什么是树形结构 树形结构是一种层级组织数据的方式，其中每个元素都与其他元素形成了分层关系，从而构成了树状的结构。树形结构的核心特点是它的分层性，其中每个节点都可以有零个或多个子节点，但只有一个父节点（除了根节点，它没有父节点）。这种结构使得数据可以以一种逻辑和有序的方式进行组织和访问 常见的应用包括文件系统、组织结">
<meta property="og:type" content="article">
<meta property="og:title" content="树和二叉树">
<meta property="og:url" content="https://017328.xyz/post/dd5c0739.html">
<meta property="og:site_name" content="cout&lt;&lt;&quot;金缕衣&quot;;">
<meta property="og:description" content="树和二叉树数据的逻辑结构     线性结构：一对一 非线性结构：一对多，多对多  树什么是树形结构 树形结构是一种层级组织数据的方式，其中每个元素都与其他元素形成了分层关系，从而构成了树状的结构。树形结构的核心特点是它的分层性，其中每个节点都可以有零个或多个子节点，但只有一个父节点（除了根节点，它没有父节点）。这种结构使得数据可以以一种逻辑和有序的方式进行组织和访问 常见的应用包括文件系统、组织结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://017328.xyz/img/shu.jpg">
<meta property="article:published_time" content="2024-04-23T06:09:35.000Z">
<meta property="article:modified_time" content="2024-06-11T11:12:14.680Z">
<meta property="article:author" content="下完这场雨">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://017328.xyz/img/shu.jpg"><link rel="shortcut icon" href="/img/icon.png"><link rel="canonical" href="https://017328.xyz/post/dd5c0739.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 下完这场雨","link":"链接: ","source":"来源: cout<<\"金缕衣\";","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '树和二叉树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-11 19:12:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script src="//code.tidio.co/xysdkaby5vgv2dt8e9zgdqsu6wh59g43.js" async></script><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/mystyle.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4770397_jz6ucve7mog.css<link rel="stylesheet" href="/css/ancientPoetry.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/h.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Video</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于帅比</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/shu.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="cout&lt;&lt;&quot;金缕衣&quot;;"><img class="site-icon" src="/img/icon.png"/><span class="site-name">cout&lt;&lt;&quot;金缕衣&quot;;</span></a></span><div id="wearher"></div><div id="tp-weather-widget"></div><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Video</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于帅比</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">树和二叉树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-23T06:09:35.000Z" title="发表于 2024-04-23 14:09:35">2024-04-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-11T11:12:14.680Z" title="更新于 2024-06-11 19:12:14">2024-06-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-c/">数据结构(C/c++)</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="树和二叉树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><p>数据的逻辑结构</p>
<img src="/post/dd5c0739/image-20240418170144113.png" class=""> 

<blockquote>
<p>线性结构：一对一</p>
<p>非线性结构：一对多，多对多</p>
</blockquote>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="什么是树形结构"><a href="#什么是树形结构" class="headerlink" title="什么是树形结构"></a>什么是树形结构</h3><blockquote>
<p>树形结构是一种层级组织数据的方式，其中<strong>每个元素都与其他元素形成了分层关系</strong>，从而构成了树状的结构。树形结构的核心特点是它的<strong>分层性</strong>，其中<strong>每个节点都可以有零个或多个子节点</strong>，但<strong>只有一个父节点</strong>（除了根节点，它没有父节点）。这种结构使得数据可以以一种逻辑和有序的方式进行组织和访问</p>
<p>常见的应用包括文件系统、组织结构图和网站导航。</p>
</blockquote>
<img src="/post/dd5c0739/image-20240418170310593.png" class="" title="image-20240418170310593"> 

<h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><blockquote>
<p>树是由<strong>根节点</strong>和<strong>一组子树构成的</strong>，而<strong>每个子树又可以递归地看作是树</strong>。</p>
<hr>
<ol>
<li><strong>树包含一个根节点</strong>，它没有父节点，且每个节点最多只有一个父节点。</li>
<li>每个节点可以有<strong>零个或多个子节点</strong>，这些子节点与父节点之间通过边相连。</li>
<li><strong>从根节点到任意节点都存在唯一的路径。</strong></li>
<li>没有环路，即树中不存在回路，任意节点到其祖先节点的路径都是唯一的。</li>
</ol>
</blockquote>
<img src="/post/dd5c0739/image-20240418170534603.png" class="" title="image-20240418170534603"> 

<h3 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h3><h4 id="树的表示-1"><a href="#树的表示-1" class="headerlink" title="树的表示"></a>树的表示</h4><img src="/post/dd5c0739/image-20240418170803390.png" class="" title="image-20240418170803390"> 

<p>集合的表示(嵌套的集合)</p>
<img src="/post/dd5c0739/image-20240418170938326.png" class="" title="image-20240418170938326"> 

<h3 id="有关树的基本术语"><a href="#有关树的基本术语" class="headerlink" title="有关树的基本术语"></a>有关树的基本术语</h3><img src="/post/dd5c0739/image-20240418171848320.png" class="" title="image-20240418171848320"> 

<blockquote>
<ol>
<li><strong>根节点（Root）</strong>：<strong>树的起始节点，它没有父节点，是树的唯一入口点。</strong></li>
<li><strong>节点（Node）</strong>：树中的一个元素，可以包含一个值，也可以包含其他附加信息。每个节点可能会有零个或多个子节点。</li>
<li><strong>父节点（Parent）</strong>：一个节点的直接上级节点。</li>
<li><strong>子节点（Child）</strong>：一个节点的直接下级节点。</li>
<li>节点的层次：从根开始根为第一次层。</li>
<li><strong>叶子节点(终端节点)（Leaf）</strong>：<strong>没有子节点的节点</strong>。</li>
<li><strong>路径（Path）</strong>：从树的一个节点到另一个节点的序列，沿着树的边走过的节点构成一条路径。</li>
<li>深度&amp;&amp;高度：树中节点的最大层次</li>
<li>节点的<strong>度</strong>（Degree）是指该<strong>节点拥有的子节点数量</strong>，即它的子树的数量。</li>
</ol>
</blockquote>
<h4 id="有序树和无序树"><a href="#有序树和无序树" class="headerlink" title="有序树和无序树"></a>有序树和无序树</h4><p>有序树（Ordered Tree）和无序树（Unordered Tree）是树的两种基本类型</p>
<p>它们之间的主要区别在于<strong>子节点的顺序是否重要。</strong></p>
<ol>
<li><p><strong>有序树</strong>：有序树中，<strong>子节点的顺序是固定的</strong>，每个子节点都有一个<strong>特定的位置</strong>。换句话说，具有不同顺序的子节点序列会产生不同的树结构。</p>
<p>在有序树中，同一个节点的子节点之间存在顺序关系。</p>
</li>
<li><p><strong>无序树</strong>：无序树中，子节点的顺序是不重要的，即使改变了子节点的顺序，树的结构仍然保持不变。</p>
<p>在无序树中，同一个节点的子节点之间不存在顺序关系。</p>
</li>
</ol>
<h4 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h4><blockquote>
<p>m棵互不相交的树的集合</p>
</blockquote>
<img src="/post/dd5c0739/image-20240418172855266.png" class="" title="image-20240418172855266"> 

<h4 id="线性结构和树结构的对比"><a href="#线性结构和树结构的对比" class="headerlink" title="线性结构和树结构的对比"></a>线性结构和树结构的对比</h4><img src="/post/dd5c0739/image-20240418172932271.png" class="" title="image-20240418172932271"> 







<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><img src="/post/dd5c0739/image-20240418173502359.png" class="" title="image-20240418173502359"> 

<ol>
<li><strong>每个节点最多有两个子节点</strong>：每个节点最多可以有两个子节点，分别称为左子节点和右子节点。这两个子节点可以存在也可以不存在。</li>
<li><strong>子节点的顺序是有序的</strong>：如果一个节点有两个子节点，那么它的左子节点和右子节点的顺序是固定的。</li>
</ol>
<p>因为树的节点可以有0或多个分支，二叉树是特殊的，只有两个叉</p>
<blockquote>
<p>而且所有的树都能转为唯一对应的二叉树</p>
<p>二叉树的操作简单，还可以和任何树相互转换</p>
<p>二叉树是有序树</p>
</blockquote>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><img src="/post/dd5c0739/image-20240418173719225.png" class="" title="image-20240418173719225"> 

<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><img src="/post/dd5c0739/image-20240418174134192.png" class="" title="image-20240418174134192"> 

<h4 id="二叉树的5种基本形态"><a href="#二叉树的5种基本形态" class="headerlink" title="二叉树的5种基本形态"></a>二叉树的5种基本形态</h4><img src="/post/dd5c0739/image-20240418174229058.png" class="" title="image-20240418174229058"> 







<h3 id="案例引入"><a href="#案例引入" class="headerlink" title="案例引入"></a>案例引入</h3><h4 id="数据压缩问题"><a href="#数据压缩问题" class="headerlink" title="数据压缩问题"></a>数据压缩问题</h4><blockquote>
<p>将数据文件转化为01组成的的人禁止串，称之为编码</p>
</blockquote>
 <img src="/post/dd5c0739/image-20240418183530328.png" class="" title="image-20240418183530328"> 

<p>学习哈夫曼树后来</p>
<h4 id="利用二叉树求解表达式的值"><a href="#利用二叉树求解表达式的值" class="headerlink" title="利用二叉树求解表达式的值"></a>利用二叉树求解表达式的值</h4><img src="/post/dd5c0739/image-20240418183726706.png" class="" title="image-20240418183726706"> 



<h3 id="二叉树的抽象数据类型定义"><a href="#二叉树的抽象数据类型定义" class="headerlink" title="二叉树的抽象数据类型定义"></a>二叉树的抽象数据类型定义</h3><img src="/post/dd5c0739/image-20240418183950690.png" class="" title="image-20240418183950690">   ![image-20240418184004390](../../../../S2024/%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584%25E7%25AC%25AC5%25E5%2591%25A8/image-20240418184004390.png) 



<h3 id="二叉树的性质和存储结构"><a href="#二叉树的性质和存储结构" class="headerlink" title="二叉树的性质和存储结构"></a>二叉树的性质和存储结构</h3><h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4><h5 id="性质1i层上最多有"><a href="#性质1i层上最多有" class="headerlink" title="性质1i层上最多有"></a>性质1i层上最多有</h5><blockquote>
<p>性质1：二叉树的第i层上最多有2<sup>i-1</sup>次方个节点(i&gt;&#x3D;1)33333333333333333333333333333</p>
</blockquote>
<img src="/post/dd5c0739/image-20240418184300405.png" class="" title="image-20240418184300405"> 

<p>证明:</p>
<img src="/post/dd5c0739/image-20240418184420754.png" class="" title="image-20240418184420754"> 

<p>思考：</p>
<blockquote>
<p>二叉树第i层上<strong>至少有1个节点</strong></p>
</blockquote>
<h5 id="深度为k的二叉树最多"><a href="#深度为k的二叉树最多" class="headerlink" title="深度为k的二叉树最多"></a>深度为k的二叉树最多</h5><blockquote>
<p>深度为k的二叉树最多有2<sup>k</sup>-1个节点</p>
</blockquote>
<p>等比数列求和</p>
<img src="/post/dd5c0739/image-20240418184813329.png" class="" title="image-20240418184813329"> 

<p>思考：</p>
<blockquote>
<p>深度为k的二叉树最少有k个节点</p>
<p>单只的！</p>
</blockquote>
<h5 id="n0-n2-1。"><a href="#n0-n2-1。" class="headerlink" title="n0 &#x3D; n2 + 1。"></a>n<sub>0</sub> &#x3D; n<sub>2</sub> + 1。</h5><p>对任何一棵二叉树 T，如果其叶子数为 n<sub>0</sub>，度为 2 的结点数为 n2，</p>
<p>则 n<sub>0</sub> &#x3D; n<sub>2</sub> + 1。</p>
<img src="/post/dd5c0739/image-20240418185611681.png" class="" title="image-20240418185611681"> s

<p>证明：</p>
<p>分别从下到上和从上到下分析边数的问题，然后求解！</p>
<img src="/post/dd5c0739/image-20240418190012862.png" class="" title="image-20240418190012862"> 

<img src="/post/dd5c0739/image-20240419103251226.png" class="" title="image-20240419103251226"> 



<h3 id="特殊形式的二叉树"><a href="#特殊形式的二叉树" class="headerlink" title="特殊形式的二叉树"></a>特殊形式的二叉树</h3><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><blockquote>
<p>满二叉树是一种<strong>特殊类型的二叉树</strong>，它具有以下两个特点：</p>
<ol>
<li><strong>每个节点要么没有子节点</strong>，要么有两个子节点。</li>
<li><strong>所有叶子节点都在同一层级上</strong>，即深度相同。</li>
</ol>
<p>满二叉树的节点数目可以通过以下公式计算：假设树的高度为h，那么节点数目为2<sup>k</sup> - 1</p>
</blockquote>
<img src="/post/dd5c0739/image-20240419103756506.png" class="" title="image-20240419103756506"> 

<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><blockquote>
<p>满二叉树在<strong>同样深度</strong>的二叉树中<strong>结点个数最多</strong></p>
<p>满二叉树在<strong>同样深度</strong>的二叉树中<strong>叶子结点个数最多</strong></p>
</blockquote>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><blockquote>
<p><strong>完全二叉树</strong>是一种<strong>特殊类型的二叉树</strong>，它具有以下两个特点：</p>
<ol>
<li><strong>所有的叶子节点都在最底层</strong>或者<strong>倒数第二层</strong>，而且<strong>最底层的叶子节点都集中在靠左的位置</strong>。</li>
<li><strong>除了最底层，其它层的节点数都达到最大</strong>，如果最底层不是满的，则缺少的节点集中在该层的右侧。</li>
</ol>
<p>与满二叉树不同，完全二叉树在<strong>保持层级结构的同时</strong>，<strong>允许最底层缺少一些节点</strong>。这种特性使得完全二叉树在实际应用中更为灵活，因为它的节点数目相对较少，同时具有较好的平衡性能。完全二叉树通常用于堆数据结构的实现，以及在一些搜索和排序算法中。</p>
</blockquote>
<img src="/post/dd5c0739/image-20240419104103260.png" class="" title="image-20240419104103260"> 

<img src="/post/dd5c0739/image-20240419104244324.png" class="" title="image-20240419104244324">

<p>都不是完全二叉树</p>
<h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h5><p>满二叉树是完全二叉树，1</p>
<blockquote>
<p>注：在满二叉树中，从<strong>最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树</strong></p>
<p><strong>一定是连续的去掉！！！！</strong></p>
</blockquote>
<img src="/post/dd5c0739/PixPin04-19_10-44-10.gif" class="" title="PixPin04-19_10-44-10"> 

<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><blockquote>
<p>特点：1.叶子只可能分布在层次最大的两层上</p>
<p>2.对任一结点，如果其右子树的最大层次为i</p>
<p><strong>则其左子树的最大层次必为i或i+1.</strong></p>
<p>满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树</p>
</blockquote>
<h4 id="完全二叉树的性质"><a href="#完全二叉树的性质" class="headerlink" title="完全二叉树的性质"></a>完全二叉树的性质</h4><h5 id="性质-4"><a href="#性质-4" class="headerlink" title="性质 4"></a>性质 4</h5><p>性质 4：具有 n 个结点的完全二叉树的深度为[log<sub>2</sub>n」+ 1。</p>
<img src="/post/dd5c0739/image-20240419105219910.png" class="" title="image-20240419105219910"> 

<h6 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h6><img src="/post/dd5c0739/image-20240419105231440.png" class="" title="image-20240419105231440"> 

<p>我们可以通过数学归纳法来证明这个性质。</p>
<p><strong>基础情况：</strong><br>当完全二叉树只有一个节点时，深度为1。<br>当 n &#x3D; 1 时，log<sub>2</sub>1 &#x3D; 0，所以深度为 log<sub>2</sub>1 + 1 &#x3D; 1，<strong>基础情况成立。</strong></p>
<p><strong>归纳假设：</strong><br>假设对于<strong>具有 k 个节点的完全二叉树</strong>，其深度为 log<sub>2</sub>k + 1 成立，其中 k ≥ 1。</p>
<p><strong>归纳步骤：</strong><br>考虑一个具有 n &#x3D; 2k + 1 或 n &#x3D; 2k + 2 个节点的完全二叉树，我们来证明其深度为 log<sub>2</sub>n + 1。</p>
<ol>
<li><p>首先，我们观察到对于完全二叉树而言，<strong>每一层的节点数都是2的幂次方</strong>。因此，对于深度为 d 的完全二叉树，其节点数 n 满足以下不等式关系：<br><strong>2<sup>d-1</sup> ≤ n &lt; 2<sup>d</sup></strong></p>
</li>
<li><p>我们对不等式两边同时取对数，得到：<br>log<sub>2</sub>(2<sup>d-1</sup>) ≤ log<sub>2</sub>n &lt; log<sub>2</sub>(2<sup>d</sup>)</p>
</li>
<li><p>进一步化简：<br>d - 1 ≤ log<sub>2</sub>n &lt; d</p>
</li>
<li><p>由于深度 d 是整数，我们可以得出：<br>d - 1 ≤ log<sub>2</sub>n &lt; d + 1</p>
</li>
<li><p>因此，我们得到了深度 d 的范围，即 log<sub>2</sub>n &lt; d &lt; log<sub>2</sub>n + 1。</p>
</li>
</ol>
<p>根据归纳假设，对于 k 个节点的完全二叉树，其深度为 log<sub>2</sub>k + 1。当 n &#x3D; 2k + 1 或 n &#x3D; 2k + 2 时，我们有：<br>log<sub>2</sub>(2k + 1) &lt; d &lt; log<sub>2</sub>(2k + 1) + 1<br>或<br>log<sub>2</sub>(2k + 2) &lt; d &lt; log<sub>2</sub>(2k + 2) + 1</p>
<p>即 log<sub>2</sub>n &lt; d &lt; log<sub>2</sub>n + 1。所以，这个性质对于任意具有 n 个节点的完全二叉树成立，通过归纳法证明了这一点。</p>
<h5 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h5> <img src="/post/dd5c0739/image-20240419110645868.png" class="" title="image-20240419110645868">

<p>性质 5：如果对一棵有 n 个节点的完全二叉树进行层序遍历编号（从第 1 层到第 ?log<sub>2</sub>n? + 1 层，每层从左到右），则对任一节点 i（1 ≤ i ≤ n），有：</p>
<ol>
<li>如果 i &#x3D; 1，则 i 是根节点；</li>
<li>如果 i &gt; 1，则节点 i 的父节点为 i&#x2F;2（整除）；</li>
<li>如果 2i &gt; n，则节点 i 为叶子节点，没有左子节点；否则，节点 i 的左子节点为 2i</li>
<li>如果 2i + 1 &gt; n，则节点 i 没有右子节点；否则，右子节点为 2i + 1。</li>
</ol>
<p>这个性质描述了在完全二叉树中，根据节点编号可以找到其父节点、左子节点和右子节点的规律。</p>
<h6 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h6><p>我们可以通过数学归纳法来证明这个性质。</p>
<p><strong>基础情况：</strong><br>对于<strong>完全二叉树中的第一个节点 i &#x3D; 1</strong>，显然它是根节点，且没有父节点，<strong>左子节点为 2 * 1 &#x3D; 2，右子节点为 2 * 1 + 1 &#x3D; 3。</strong></p>
<p><strong>归纳假设：</strong><br>假设对于完全二叉树中的某个节点 i（其中 1 ≤ i ≤ n），其父节点、左子节点和右子节点的关系满足描述。</p>
<p><strong>归纳步骤：</strong><br>考虑完全二叉树中的任意节点 i，我们来证明其父节点、左子节点和右子节点的关系仍然满足描述。</p>
<ol>
<li>如果 2i &gt; n，<strong>则节点 i 没有左子节点。这是因为节点 i 的左子节点编号为 2i</strong>，但是大于了总节点数 n，意味着树中<strong>不存在编号为 2i 的节点</strong>，因此节点 i <strong>没有左子节点</strong>。这也符合描述中的要求。</li>
<li>如果 2i + 1 &gt; n，<strong>则节点 i 没有右子节点</strong>。同样的道理，节点 i 的<strong>右子节点编号为 2i + 1</strong>，但是大于了总节点数 n，所以<strong>节点 i 没有右子节点</strong>，也满足描述中的要求。</li>
<li>对于其余情况，即 2i ≤ n 且 2i + 1 ≤ n，节点 i 存在左子节点和右子节点。这个情况下，根据归纳假设，节点 i 的左子节点为 2i，右子节点为 2i + 1，依然符合描述。</li>
</ol>
<p>综上所述，对于完全二叉树中的任意节点 i，其父节点、左子节点和右子节点的关系满足描述。因此，这个性质得到了证明。</p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h4><h5 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的顺序存储</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAXSIZE];</span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>按满二叉树的节点层次编号，依次存放二叉树种的元素</p>
</blockquote>
<h5 id="完全二叉树如何存储？"><a href="#完全二叉树如何存储？" class="headerlink" title="完全二叉树如何存储？"></a>完全二叉树如何存储？</h5><img src="/post/dd5c0739/image-20240419114759771.png" class="" title="image-20240419114759771"> 

<h5 id="一般二叉树如何存储？"><a href="#一般二叉树如何存储？" class="headerlink" title="一般二叉树如何存储？"></a>一般二叉树如何存储？</h5><blockquote>
<p>那就按照满而二叉树那样标号，然后有元素的放元素，没有的就放空，要正确的描述空节点</p>
</blockquote>
<img src="/post/dd5c0739/image-20240419115158849.png" class="" title="image-20240419115158849"> 

<h5 id="顺序存储还原二叉树"><a href="#顺序存储还原二叉树" class="headerlink" title="顺序存储还原二叉树"></a>顺序存储还原二叉树</h5><blockquote>
<p>先画出对应 的满二叉树并编号，然后一一填空</p>
</blockquote>
<img src="/post/dd5c0739/image-20240419115449058.png" class="" title="image-20240419115449058"> 

<h5 id="顺序存储的特点"><a href="#顺序存储的特点" class="headerlink" title="顺序存储的特点"></a>顺序存储的特点</h5><blockquote>
<ol>
<li>大小固定，定长的，就不灵活</li>
<li>空节点在顺序表中不存或者存空，必须空一些元素，所以最坏的情况下却要浪费很多空间(<code>最坏的情况例如右单只树</code>),存储密度小</li>
</ol>
</blockquote>
<img src="/post/dd5c0739/image-20240419115719988.png" class="" title="image-20240419115719988"> 

<blockquote>
<p>所以适合满二叉树或者完全二叉树存储！</p>
<p>特点:<strong>结点间关系蕴含在其存储位置中</strong></p>
<p>浪费空间，适于存满二叉树和完全二叉树</p>
</blockquote>
<h4 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h4><h5 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h5><img src="/post/dd5c0739/image-20240419115948161.png" class="" title="image-20240419115948161"> 

<h6 id="二叉链表存储结构"><a href="#二叉链表存储结构" class="headerlink" title="二叉链表存储结构"></a>二叉链表存储结构</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> &#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125; BiNode, *BiTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>BiNode, BiTree分别是用来定义变量和对应的指针类型</p>
<h5 id="图形描述"><a href="#图形描述" class="headerlink" title="图形描述"></a>图形描述</h5><blockquote>
<p>有了头指针，然后顺藤摸瓜</p>
</blockquote>
<img src="/post/dd5c0739/image-20240419120445797.png" class="" title="image-20240419120445797"> 

<h5 id="思考？"><a href="#思考？" class="headerlink" title="思考？"></a>思考？</h5><blockquote>
<p>在<strong>n个节点的二叉链表</strong>中，有多少个<strong>空指针域</strong>？</p>
<p>分析：<strong>必有2n个链域</strong>。也就是2n个指针域！</p>
<p>除根结点外每个结点有且仅有一个双亲</p>
<p>所以只会有n－1个结点的链域存放指针指向非空子女结点</p>
<p>（数边，除了根节点没有指向双亲的线，其他的节点都有，所以就是n-1）</p>
<hr>
<p><strong>空指针树&#x3D;2n-(n-1)&#x3D;n+1个</strong></p>
</blockquote>
<h5 id="三叉链表"><a href="#三叉链表" class="headerlink" title="三叉链表"></a>三叉链表</h5><img src="/post/dd5c0739/image-20240419120921990.png" class="" title="image-20240419120921990"> 

<h6 id="三叉链表存储结构"><a href="#三叉链表存储结构" class="headerlink" title="三叉链表存储结构"></a>三叉链表存储结构</h6><blockquote>
<p>又多了一个指向双亲的指针！</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> &#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">lchild</span>, *<span class="title">parent</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; TriTNode, *TriTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><h4 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h4><blockquote>
<p>遍历定义一一<strong>顺着某一条搜索路径巡访二叉树中的结点</strong>，使得<strong>每个结点均被访问一次</strong>，而且<strong>仅被访问一次</strong> (又称周游)</p>
</blockquote>
<p><code>&quot;访问”</code>的含义很广，可以是对结点作各种处理</p>
<p>如：输出结点的信息、修改结点的数据值等，但要求这种访问<strong>不破坏原来的数据结构。</strong></p>
<blockquote>
<p><strong>遍历目的一一得到树中所有结点的一个线性排列</strong></p>
</blockquote>
<blockquote>
<p><strong>遍历用途——它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心</strong></p>
</blockquote>
<h4 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h4><img src="/post/dd5c0739/image-20240419121410451.png" class="" title="image-20240419121410451"> 

<p>若规定先左后右，则只有前三种情况：</p>
<blockquote>
<p>DLR先 (根)序遍历</p>
<p>LDR中 (根)序遍历</p>
<p>LRD一后 (根)序遍历</p>
</blockquote>
<img src="/post/dd5c0739/image-20240419121535386.png" class="" title="image-20240419121535386"> 

<h4 id="遍历方法的算法描述"><a href="#遍历方法的算法描述" class="headerlink" title="遍历方法的算法描述"></a>遍历方法的算法描述</h4><table>
<thead>
<tr>
<th>先序遍历</th>
<th>中序遍历</th>
<th>后序遍历</th>
</tr>
</thead>
<tbody><tr>
<td>若二叉树为空，则空操作否则</td>
<td>否则若二叉树为空，则空操作否则</td>
<td>否则若二叉树为空，则空操作否则</td>
</tr>
<tr>
<td>(1) <strong>先序遍历左子树</strong></td>
<td>(1) <strong>中序遍历</strong>左子树</td>
<td>(1) <strong>后序遍历左子树</strong></td>
</tr>
<tr>
<td>(2) <strong>先序遍历右子树</strong></td>
<td>(2) 访问<strong>根结点</strong></td>
<td>(2) <strong>后序遍历右子树</strong></td>
</tr>
<tr>
<td>(3) <strong>访问根结点</strong></td>
<td>(3) <strong>中序遍历</strong>右子树</td>
<td>(3) <strong>访问根结点</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>由二叉树的递归定义可知，遍历左子树和遍历右子树<strong>可如同遍历二叉树一样“递归”进行</strong></p>
</blockquote>
<h4 id="遍历的操作定义"><a href="#遍历的操作定义" class="headerlink" title="遍历的操作定义"></a>遍历的操作定义</h4><h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><img src="/post/dd5c0739/image-20240419122641368.png" class="" title="image-20240419122641368"> 

<img src="/post/dd5c0739/image-20240419122507427.png" class="" title="image-20240419122507427"> 

<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><img src="/post/dd5c0739/image-20240419122845181.png" class="" title="image-20240419122845181"> 

<img src="/post/dd5c0739/image-20240419122516909.png" class="" title="image-20240419122516909"> 

<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><img src="/post/dd5c0739/image-20240419123035357.png" class="" title="image-20240419123035357"> 

<img src="/post/dd5c0739/image-20240419122526422.png" class="" title="image-20240419122526422"> 







<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><img src="/post/dd5c0739/image-20240419122712901.png" class="" title="image-20240419122051004](..&#x2F;..&#x2F;..&#x2F;..&#x2F;S2024&#x2F;%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584%25E7%25AC%25AC5%25E5%2591%25A8&#x2F;image-20240419122051004.png) ![image-20240419122712901"> 

<blockquote>
<p>先序遍历:A  B  E  L  D  H  M  I  J</p>
</blockquote>
<img src="/post/dd5c0739/image-20240419122859912.png" class="" title="image-20240419122859912"> 

<blockquote>
<p>中遍历: E	L	B	A	M	H	I	D	J</p>
</blockquote>
<img src="/post/dd5c0739/image-20240419123048287.png" class="" title="image-20240419123048287"> 

<blockquote>
<p>后续遍历：L	E	B	M	I	H	J	D	A</p>
</blockquote>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><img src="/post/dd5c0739/image-20240419123215169.png" class="" title="image-20240419123215169"> 

<h5 id="用二叉树表示算数表达式"><a href="#用二叉树表示算数表达式" class="headerlink" title="用二叉树表示算数表达式"></a>用二叉树表示算数表达式</h5><img src="/post/dd5c0739/image-20240419123343848.png" class="" title="image-20240419123343848"> 

<h4 id="根据遍历序列得到二叉树"><a href="#根据遍历序列得到二叉树" class="headerlink" title="根据遍历序列得到二叉树"></a>根据遍历序列得到二叉树</h4><blockquote>
<p> 若二叉树中各节点的值均不相同，则二叉树节点的先序序列、中序序列和后序序列都是唯一的。</p>
<p> 由二叉树的</p>
<p> <strong>先序序列和中序序列</strong>或<strong>由二叉树的后序序列和中序序列</strong></p>
<p> 可以<strong>确定唯一的一棵二叉树</strong>。</p>
<p> 只有先后是不可以确定一颗二叉树的</p>
</blockquote>
<h5 id="要掌握的技巧"><a href="#要掌握的技巧" class="headerlink" title="要掌握的技巧"></a>要掌握的技巧</h5><p>根据先序或者后续得到根</p>
<p>然后根据中序得到简单的字树分布</p>
<blockquote>
<p>根据先序和后序可以得到</p>
<ol>
<li>谁是根？</li>
<li>根的左右子树是？</li>
<li>逐渐确定二叉树</li>
</ol>
</blockquote>
<h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><img src="/post/dd5c0739/image-20240419130301074.png" class="" title="image-20240419130301074"> 

<img src="/post/dd5c0739/image-20240419130228410.png" class="" title="image-20240419130228410"> 

<hr>
<img src="/post/dd5c0739/image-20240419130424971.png" class="" title="image-20240419130424971"> 



<h4 id="递归遍历算法的实现"><a href="#递归遍历算法的实现" class="headerlink" title="递归遍历算法的实现"></a>递归遍历算法的实现</h4><h5 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h5><img src="/post/dd5c0739/image-20240419142651673.png" class="" title="image-20240419142651673">

<img src="/post/dd5c0739/image-20240419143122616.png" class="" title="image-20240419143122616">  

<blockquote>
<p>递归！</p>
<ol>
<li>访问根节点。</li>
<li>递归地对左子树进行先序遍历。</li>
<li>递归地对右子树进行先序遍历。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义二叉树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"><span class="comment">// 先序遍历函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preorderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问根节点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val);</span><br><span class="line">    <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    preorderTraversal(root-&gt;left);</span><br><span class="line">    <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    preorderTraversal(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先序的遍历序列:ABDC</p>
</blockquote>
<img src="/post/dd5c0739/image-20240419143536420.png" class="" title="image-20240419143536420"> 

<h5 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h5><blockquote>
<p>若二叉树为空，则空操作</p>
<p>否则：中序遍历左子树（L）访问根结点（D）中序遍历右子树对（R）</p>
</blockquote>
<img src="/post/dd5c0739/image-20240419144041192.png" class="" title="image-20240419144041192">

<img src="/post/dd5c0739/image-20240419144156214.png" class="" title="image-20240419144156214">  

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义二叉树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    inorderTraversal(root-&gt;left);</span><br><span class="line">    <span class="comment">// 访问根节点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val);</span><br><span class="line">    <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    inorderTraversal(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h5><blockquote>
<p>若二叉树为空，则空操作否则</p>
<p>后序遍历左子树</p>
<p>后序遍历右子树汇(R)</p>
<p>访问根结点(D)</p>
</blockquote>
<img src="/post/dd5c0739/image-20240419144301682.png" class="" title="image-20240419144301682"> 

<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><img src="/post/dd5c0739/image-20240419144350672.png" class="" title="image-20240419144350672"> 

<img src="/post/dd5c0739/image-20240419144540381.png" class="" title="image-20240419144540381"> 

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><blockquote>
<p>算法复杂度分析如下：</p>
<ol>
<li><p>时间复杂度：**每个节点都只会被访问一次，所以时间复杂度为 O(n)**，其中 <strong>n 是二叉树中的节点数</strong>。</p>
</li>
<li><p>空间复杂度：<strong>递归调用的栈空间是关键</strong>。由于<strong>每次递归调用都会压入栈中</strong>，最坏情况下，<strong>栈的深度等于二叉树的高度</strong>。</p>
<p>对于平衡二叉树来说，树的高度为 log(n)，其中 n 是节点数。因此，空间复杂度为 <strong>O(log(n))。</strong></p>
<p>而对于不平衡的二叉树，最坏情况下栈的深度为 n，此时空间复杂度为 <strong>O(n)。</strong></p>
</li>
</ol>
<p>总的来说，先序、中序和后序遍历算法的时间复杂度均为 O(n)，空间复杂度在平衡情况下为 O(log(n))，在最坏情况下为 O(n)。</p>
</blockquote>
<h4 id="非递归遍历算法的实现"><a href="#非递归遍历算法的实现" class="headerlink" title="非递归遍历算法的实现"></a>非递归遍历算法的实现</h4><p>以中序遍历为例</p>
<blockquote>
<p>用栈来实现</p>
</blockquote>
<img src="/post/dd5c0739/image-20240419145245769.png" class="" title="image-20240419145245769"> 

<img src="/post/dd5c0739/PixPin04-19_14-55-54.gif" class="" title="PixPin04-19_14-55-54"> 

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    Stack S;</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    <span class="keyword">while</span> (p || !StackEmpty(S)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            Push(&amp;S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Pop(&amp;S, &amp;p);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>难理解，理解每一次执行是谁入栈了，谁出栈了</p>
<h4 id="层次遍历算法"><a href="#层次遍历算法" class="headerlink" title="层次遍历算法"></a>层次遍历算法</h4><blockquote>
<p>一层一层访问，每一层从左到右访问。</p>
</blockquote>
<img src="/post/dd5c0739/image-20240419150249797.png" class="" title="image-20240419150249797"> 

<h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><img src="/post/dd5c0739/image-20240419150328102.png" class="" title="image-20240419150328102"> 

<img src="/post/dd5c0739/PixPin04-19_15-11-42.gif" class="" title="PixPin04-19_15-11-42">

<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><img src="/post/dd5c0739/image-20240419151314745.png" class="" title="image-20240419151314745"> 

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    TreeNode *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    QueueNode *front;</span><br><span class="line">    QueueNode *rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initQueue</span><span class="params">(Queue *q)</span> &#123;</span><br><span class="line">    q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(Queue *q, TreeNode *node)</span> &#123;</span><br><span class="line">    QueueNode *newNode = (QueueNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span> (!newNode) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Memory allocation failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = node;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;rear == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;front = newNode;</span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;rear-&gt;next = newNode;</span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">TreeNode *<span class="title function_">dequeue</span><span class="params">(Queue *q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode *temp = q-&gt;front;</span><br><span class="line">    TreeNode *node = temp-&gt;data;</span><br><span class="line">    q-&gt;front = q-&gt;front-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层次遍历函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">levelOrderTraversal</span><span class="params">(TreeNode *root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue q;</span><br><span class="line">    initQueue(&amp;q);</span><br><span class="line">    enqueue(&amp;q, root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.front != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        TreeNode *node = dequeue(&amp;q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            enqueue(&amp;q, node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            enqueue(&amp;q, node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新节点的函数</span></span><br><span class="line">TreeNode *<span class="title function_">createNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    TreeNode *newNode = (TreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    <span class="keyword">if</span> (!newNode) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Memory allocation failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;val = val;</span><br><span class="line">    newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一棵示例二叉树</span></span><br><span class="line">    TreeNode *root = createNode(<span class="number">1</span>);</span><br><span class="line">    root-&gt;left = createNode(<span class="number">2</span>);</span><br><span class="line">    root-&gt;right = createNode(<span class="number">3</span>);</span><br><span class="line">    root-&gt;left-&gt;left = createNode(<span class="number">4</span>);</span><br><span class="line">    root-&gt;left-&gt;right = createNode(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层次遍历二叉树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Level order traversal: &quot;</span>);</span><br><span class="line">    levelOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(root-&gt;left-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(root-&gt;left-&gt;left);</span><br><span class="line">    <span class="built_in">free</span>(root-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="遍历算法的应用"><a href="#遍历算法的应用" class="headerlink" title="&#x3D;&#x3D;遍历算法的应用&#x3D;&#x3D;"></a>&#x3D;&#x3D;遍历算法的应用&#x3D;&#x3D;</h3><h4 id="建立二叉树"><a href="#建立二叉树" class="headerlink" title="建立二叉树"></a>建立二叉树</h4><blockquote>
<p>先序遍历序列建立二叉链表</p>
</blockquote>
<p>因为，仅仅根据先序序列，构造出来的二叉树不唯一</p>
<p>所以要改进,想要哪一种，然后补充对应的空节点，然后更新先序序列，然后键入</p>
<img src="/post/dd5c0739/image-20240419151913558.png" class="" title="image-20240419151913558"> 

<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><img src="/post/dd5c0739/image-20240419152623617.png" class="" title="image-20240419152623617">  

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建二叉树</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree *T)</span> &#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">    getchar(); <span class="comment">// 吸收输入缓冲区中的换行符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        <span class="keyword">if</span> (!*T) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        <span class="comment">// 递归构造左子树</span></span><br><span class="line">        <span class="keyword">if</span> (CreateBiTree(&amp;(*T)-&gt;lchild) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归构造右子树</span></span><br><span class="line">        <span class="keyword">if</span> (CreateBiTree(&amp;(*T)-&gt;rchild) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyBiTree</span><span class="params">(BiTree *T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*T) &#123;</span><br><span class="line">        DestroyBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">        DestroyBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(*T);</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入二叉树的先序序列（以“#”表示空节点）：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (CreateBiTree(&amp;T) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;二叉树构建失败。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二叉树构建成功。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁二叉树释放内存</span></span><br><span class="line">    DestroyBiTree(&amp;T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="复制二叉树"><a href="#复制二叉树" class="headerlink" title="复制二叉树"></a>复制二叉树</h4><p>以先序遍历</p>
<blockquote>
<p>如果是空树，递归结束;</p>
<p>否则，申请新结点空间，复制根结点</p>
<ul>
<li>递归复制左子树<ul>
<li>递归复制右子树</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复制二叉树</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Copy</span><span class="params">(BiTree T, BiTree *NewT)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果是空树返回0</span></span><br><span class="line">        *NewT = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *NewT = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        <span class="keyword">if</span> (!*NewT) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        (*NewT)-&gt;data = T-&gt;data;</span><br><span class="line">        <span class="comment">// 复制左子树</span></span><br><span class="line">        Copy(T-&gt;lchild, &amp;(*NewT)-&gt;lchild);</span><br><span class="line">        <span class="comment">// 复制右子树</span></span><br><span class="line">        Copy(T-&gt;rchild, &amp;(*NewT)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><img src="/post/dd5c0739/image-20240419154145996.png" class="" title="image-20240419154145996"> 

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制二叉树</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Copy</span><span class="params">(BiTree T, BiTree *NewT)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果是空树返回0</span></span><br><span class="line">        *NewT = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *NewT = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        <span class="keyword">if</span> (!*NewT) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        (*NewT)-&gt;data = T-&gt;data;</span><br><span class="line">        <span class="comment">// 复制左子树</span></span><br><span class="line">        Copy(T-&gt;lchild, &amp;(*NewT)-&gt;lchild);</span><br><span class="line">        <span class="comment">// 复制右子树</span></span><br><span class="line">        Copy(T-&gt;rchild, &amp;(*NewT)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyBiTree</span><span class="params">(BiTree *T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*T) &#123;</span><br><span class="line">        DestroyBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">        DestroyBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(*T);</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraversal</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        InOrderTraversal(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">        InOrderTraversal(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    BiTree T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 创建一棵示例二叉树</span></span><br><span class="line">    T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;data = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    T-&gt;lchild = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;lchild-&gt;data = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    T-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;lchild-&gt;rchild =(BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;lchild-&gt;rchild-&gt;data = <span class="string">&#x27;D&#x27;</span>; <span class="comment">// 将 &#x27;D&#x27; 作为 &#x27;B&#x27; 的右孩子</span></span><br><span class="line">    </span><br><span class="line">    T-&gt;lchild-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;lchild-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    T-&gt;rchild = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;rchild-&gt;data = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    T-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制二叉树</span></span><br><span class="line">    BiTree NewT = <span class="literal">NULL</span>;</span><br><span class="line">    Copy(T, &amp;NewT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原二叉树中序遍历结果：&quot;</span>);</span><br><span class="line">    InOrderTraversal(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;复制的二叉树中序遍历结果：&quot;</span>);</span><br><span class="line">    InOrderTraversal(NewT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁原二叉树释放内存</span></span><br><span class="line">    DestroyBiTree(&amp;T);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁复制的二叉树释放内存</span></span><br><span class="line">    DestroyBiTree(&amp;NewT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/post/dd5c0739/image-20240419153944602.png" class="" title="image-20240419153944602"> 







<h4 id="计算二叉树的深度"><a href="#计算二叉树的深度" class="headerlink" title="计算二叉树的深度"></a>计算二叉树的深度</h4><blockquote>
<p>递归地计算左右子树的深度，并返回较大值加上根节点的深度。</p>
<ol>
<li>如果树为空，则深度为0。</li>
<li>否则，递归地计算左子树的深度（左子树为空时深度为0），并将其存储在变量 <code>leftDepth</code> 中。</li>
<li>递归地计算右子树的深度（右子树为空时深度为0），并将其存储在变量 <code>rightDepth</code> 中。</li>
<li>返回左右子树深度的较大值加上1（因为根节点也算一层）作为树的深度。</li>
</ol>
<p>这样的递归过程会不断地向下探索树的每个分支，直到遇到空节点为止。通过不断向上返回深度信息，并不断比较左右子树的深度，最终得到整棵树的深度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算二叉树的深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">TreeDepth</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 递归计算左子树的深度</span></span><br><span class="line">        <span class="type">int</span> leftDepth = TreeDepth(T-&gt;lchild);</span><br><span class="line">        <span class="comment">// 递归计算右子树的深度</span></span><br><span class="line">        <span class="type">int</span> rightDepth = TreeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="comment">// 返回左右子树深度的较大值加上根节点的深度（1）</span></span><br><span class="line">        <span class="keyword">return</span> (leftDepth &gt; rightDepth ? leftDepth : rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5><img src="/post/dd5c0739/image-20240419154531580.png" class="" title="image-20240419154531580"> 

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算二叉树的深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">TreeDepth</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 递归计算左子树的深度</span></span><br><span class="line">        <span class="type">int</span> leftDepth = TreeDepth(T-&gt;lchild);</span><br><span class="line">        <span class="comment">// 递归计算右子树的深度</span></span><br><span class="line">        <span class="type">int</span> rightDepth = TreeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="comment">// 返回左右子树深度的较大值加上根节点的深度（1）</span></span><br><span class="line">        <span class="keyword">return</span> (leftDepth &gt; rightDepth ? leftDepth : rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一棵示例二叉树</span></span><br><span class="line">    BiTree T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;data = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    T-&gt;lchild = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;lchild-&gt;data = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    T-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;rchild = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;rchild-&gt;data = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    T-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算二叉树的深度并输出结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二叉树的深度为：%d\n&quot;</span>, TreeDepth(T));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放二叉树的内存</span></span><br><span class="line">    <span class="built_in">free</span>(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">free</span>(T-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/post/dd5c0739/image-20240419154345990.png" class="" title="image-20240419154345990"> 







<h4 id="计算节点的总数"><a href="#计算节点的总数" class="headerlink" title="计算节点的总数"></a>计算节点的总数</h4><blockquote>
<p>计算二叉树节点总数的方法也可以使用递归。</p>
<ol>
<li>如果树为空，则节点总数为0。</li>
<li>否则，<strong>节点总数为根节点的值</strong>加上<strong>左子树的节点总数</strong>和<strong>右子树的节点总数之和</strong>。</li>
<li><strong>递归地计算左子树和右子树的节点总数，直到遇到空节点为止。</strong></li>
</ol>
<p>通过这样的递归过程，我们可以依次计算出二叉树中所有节点的总数。这种方法会递归地向下探索每个分支，并将节点总数不断累加，直到遇到空节点为止。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算二叉树节点总数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CountNodes</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果树为空，则节点总数为0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 节点总数为根节点的值加上左子树的节点总数和右子树的节点总数之和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + CountNodes(T-&gt;lchild) + CountNodes(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><img src="/post/dd5c0739/image-20240419154918844.png" class="" title="image-20240419154918844"> 

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算二叉树节点总数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CountNodes</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果树为空，则节点总数为0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 节点总数为根节点的值加上左子树的节点总数和右子树的节点总数之和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + CountNodes(T-&gt;lchild) + CountNodes(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一棵示例二叉树</span></span><br><span class="line">    BiTree T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;data = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    T-&gt;lchild = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;lchild-&gt;data = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    T-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;rchild = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;rchild-&gt;data = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    T-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算二叉树节点总数并输出结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二叉树节点总数为：%d\n&quot;</span>, CountNodes(T));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放二叉树的内存</span></span><br><span class="line">    <span class="built_in">free</span>(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">free</span>(T-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/post/dd5c0739/image-20240419154854929.png" class="" title="image-20240419154854929"> 





<h4 id="计算叶子节点的总数"><a href="#计算叶子节点的总数" class="headerlink" title="计算叶子节点的总数"></a>计算叶子节点的总数</h4><blockquote>
<p>计算二叉树叶子节点总数的思路也可以使用递归。</p>
<ol>
<li><strong>如果树为空，则叶子节点总数为0。</strong></li>
<li>如果树只有一个节点，则叶子节点总数为1（因为根节点是叶子节点）。</li>
<li>否则，<strong>叶子节点总数</strong>为<strong>左子树的叶子节点总数</strong>加上<strong>右子树的叶子节点总数</strong>之和。</li>
<li>递归地计算左子树和右子树的叶子节点总数，直到遇到叶子节点为止。</li>
</ol>
<p>通过这样的递归过程，我们可以依次计算出二叉树中所有叶子节点的总数。这种方法会递归地向下探索每个分支，并将叶子节点总数不断累加，直到遇到叶子节点为止。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算二叉树叶子节点总数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CountLeaves</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 1. 如果树为空，则叶子节点总数为0。这是递归的终止条件之一，因为空树没有叶子节点。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 如果树只有一个节点，则叶子节点总数为1（根节点是叶子节点）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 叶子节点总数为左子树的叶子节点总数加上右子树的叶子节点总数之和</span></span><br><span class="line">        <span class="keyword">return</span> CountLeaves(T-&gt;lchild) + CountLeaves(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h5><img src="/post/dd5c0739/image-20240419155444348.png" class="" title="image-20240419155444348"> 

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算二叉树叶子节点总数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CountLeaves</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果树为空，则叶子节点总数为0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 如果树只有一个节点，则叶子节点总数为1（根节点是叶子节点）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 叶子节点总数为左子树的叶子节点总数加上右子树的叶子节点总数之和</span></span><br><span class="line">        <span class="keyword">return</span> CountLeaves(T-&gt;lchild) + CountLeaves(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一棵示例二叉树</span></span><br><span class="line">    BiTree T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;data = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    T-&gt;lchild = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;lchild-&gt;data = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    T-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;rchild = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    T-&gt;rchild-&gt;data = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    T-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算二叉树叶子节点总数并输出结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二叉树叶子节点总数为：%d\n&quot;</span>, CountLeaves(T));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放二叉树的内存</span></span><br><span class="line">    <span class="built_in">free</span>(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">free</span>(T-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="忠告"><a href="#忠告" class="headerlink" title="忠告"></a>忠告</h4><blockquote>
<p>要求:实现能自己写出</p>
<p>眼高手低不可取</p>
</blockquote>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h4 id="为什么需要线索二叉树？"><a href="#为什么需要线索二叉树？" class="headerlink" title="为什么需要线索二叉树？"></a>为什么需要线索二叉树？</h4><img src="/post/dd5c0739/image-20240421153436480.png" class="" title="image-20240421153436480"> 

<h4 id="线索二叉树的引入"><a href="#线索二叉树的引入" class="headerlink" title="线索二叉树的引入"></a>线索二叉树的引入</h4><p>解决的方法：<strong>通过遍历 寻找费时间</strong></p>
<p><strong>再增设前驱、后继指针域增加了存储负担</strong></p>
<p><strong>利用二叉链表中的空指针域</strong></p>
<img src="/post/dd5c0739/image-20240421153651854.png" class="" title="image-20240421153651854"> 

<blockquote>
<p>利用二叉链表中的空指针域</p>
<p>如果某个节点的左孩子为空，则将空的左孩子指针域改为指向其前驱；</p>
<p>如果某节点的右孩子为空，则将空的右孩子指针域改为指向其后继。</p>
<p>这种改变指向的指针称为“线索”。加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。</p>
<p>对二叉树按某种遍历次序使其变为线索二叉树的过程叫做线索化。</p>
</blockquote>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><blockquote>
<p>画箭头，一般配合什么序遍历的线索二叉树,根据序列来对应前驱后继。。</p>
</blockquote>
<img src="/post/dd5c0739/image-20240421154109218.png" class="" title="image-20240421154109218"> 

<h4 id="线索二叉树的节点的结构"><a href="#线索二叉树的节点的结构" class="headerlink" title="线索二叉树的节点的结构"></a>线索二叉树的节点的结构</h4><p>但是一个节点只有lchild和rchild，如何区分是指向前驱还是左孩子呢？</p>
<blockquote>
<p>为了区分 <code>lchild</code> 和 <code>rchild</code> 指针到底是指向孩子的指针还是指向前驱或后继的指针，对七叉链表中的每个节点增设两个标志域 <code>Itag</code> 和 <code>rtag</code>，并约定：</p>
<ul>
<li>当 <code>ltag=0</code> 时，<code>lchild</code> 指向该节点的左孩子；当 <code>ltag=1</code> 时，<code>lchild</code> 指向该节点的前驱。</li>
<li>当 <code>rtag=0</code> 时，<code>rchild</code> 指向该节点的右孩子；当 <code>rtag=1</code> 时，<code>rchild</code> 指向该节点的后继。</li>
</ul>
</blockquote>
<h5 id="线索二叉树的结构"><a href="#线索二叉树的结构" class="headerlink" title="线索二叉树的结构"></a>线索二叉树的结构</h5><img src="/post/dd5c0739/image-20240421154403117.png" class="" title="image-20240421154403117"> 

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> Itag, rtag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="三种线索二叉树"><a href="#三种线索二叉树" class="headerlink" title="三种线索二叉树"></a>三种线索二叉树</h4><h5 id="先序线索二叉树"><a href="#先序线索二叉树" class="headerlink" title="先序线索二叉树"></a>先序线索二叉树</h5><img src="/post/dd5c0739/image-20240421154541216.png" class="" title="image-20240421154541216"> 

<h5 id="中序线索二叉树"><a href="#中序线索二叉树" class="headerlink" title="中序线索二叉树"></a>中序线索二叉树</h5><img src="/post/dd5c0739/image-20240421154604240.png" class="" title="image-20240421154604240"> 

<h5 id="后续线索二叉树"><a href="#后续线索二叉树" class="headerlink" title="后续线索二叉树"></a>后续线索二叉树</h5><img src="/post/dd5c0739/image-20240421154729740.png" class="" title="image-20240421154729740"> 

<h4 id="引入头节点的线索二叉树"><a href="#引入头节点的线索二叉树" class="headerlink" title="引入头节点的线索二叉树"></a>引入头节点的线索二叉树</h4><img src="/post/dd5c0739/image-20240421155125405.png" class="" title="image-20240421155125405"> 

<blockquote>
<p> 悬空了两个指针，空着也ok但是</p>
<p> 可以增加一个头节点啊</p>
</blockquote>
<img src="/post/dd5c0739/image-20240421155158632.png" class="" title="image-20240421155158632"> 





<h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h2><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><blockquote>
<p>双亲表示法是一种树的存储结构，用于表示树中节点之间的父子关系。</p>
<p>树中的每个节点，都有<strong>一个指向其父节点的指针或索引</strong>。</p>
<p>通常情况下，可以使用<strong>一个数组来表示树的各个节点</strong>，<strong>数组中的每个元素存储一个节点的信息</strong>，其中包括<strong>节点的数据</strong>以及<strong>指向父节点的指针</strong>或<strong>父节点在数组中的索引</strong>。</p>
</blockquote>
<img src="/post/dd5c0739/image-20240421155952648.png" class="" title="image-20240421155952648"> 

<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><img src="/post/dd5c0739/image-20240421160254535.png" class="" title="image-20240421160254535"> 

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 树的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data; <span class="comment">// 节点数据</span></span><br><span class="line">    <span class="type">int</span> parentIndex; <span class="comment">// 父节点在数组中的索引</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE  100</span></span><br><span class="line"><span class="comment">// 树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TreeNode nodes[MAX_TREE_SIZE]; <span class="comment">// 存储树中所有节点的数组</span></span><br><span class="line">    <span class="type">int</span> r,n; <span class="comment">// 根节点的位置和树中节点的数量</span></span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><blockquote>
<ol>
<li><strong>查找父节点方便：</strong> 由于每个节点都知道其父节点的位置或索引，因此在双亲表示法中查找父节点非常方便和高效。</li>
<li><strong>查找兄弟节点需要遍历：</strong> 虽然查找父节点方便，但是如果要查找兄弟节点，通常需要遍历父节点的子节点列表，相对而言效率略低。</li>
</ol>
</blockquote>
<h4 id="孩子链表"><a href="#孩子链表" class="headerlink" title="孩子链表"></a>孩子链表</h4><blockquote>
<p><strong>每个节点的孩子节点排列起来</strong>，被视为一个<strong>线性表</strong>，<strong>使用单链表存储</strong>，因此对于<strong>树中的每个节点</strong>，都有一个孩子链表。</p>
<p>假设树中有 n 个节点，则有 n 个孩子链表（叶子节点的孩子链表为空表）。</p>
<p><strong>孩子链表的头指针被组织成一个线性表</strong>，使用顺序表（包含 n 个元素的结构数组）存储。</p>
</blockquote>
<img src="/post/dd5c0739/image-20240421160749348.png" class="" title="image-20240421160749348"> 

<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><img src="/post/dd5c0739/image-20240421161221723.png" class="" title="image-20240421161221723"> 

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *ChildPtr; <span class="comment">// 孩子链表头指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr firstchild; <span class="comment">// 孩子链表头指针</span></span><br><span class="line">&#125; CTBox; <span class="comment">// 孩子结点结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n, r; <span class="comment">// 结点数和根结点的位置</span></span><br><span class="line">&#125; CTree; <span class="comment">// 树结构</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h5><blockquote>
<p>找孩子容易，找双亲难。</p>
</blockquote>
<h5 id="结合双亲表示法"><a href="#结合双亲表示法" class="headerlink" title="结合双亲表示法"></a>结合双亲表示法</h5><blockquote>
<p>带双亲的孩子链表</p>
</blockquote>
<img src="/post/dd5c0739/image-20240421161531880.png" class="" title="image-20240421161531880"> 



<h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="&#x3D;&#x3D;孩子兄弟表示法&#x3D;&#x3D;"></a>&#x3D;&#x3D;孩子兄弟表示法&#x3D;&#x3D;</h4><blockquote>
<p>二叉树表示法，二叉链表表示法;</p>
</blockquote>
<p>实现：用二叉链表作树的存储结构，链表中每个结点的<strong>两个指针域</strong>分别指向其<strong>第一个孩子结点</strong>和下一个兄弟结点</p>
<img src="/post/dd5c0739/image-20240421162232557.png" class="" title="image-20240421162232557"> 







<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>;</span>  <span class="comment">// 指向第一个孩子节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">nextsibling</span>;</span> <span class="comment">// 指向下一个兄弟节点</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h5><blockquote>
<p>找双亲比较困难，找孩子和兄弟方便</p>
<p>或者再增加指针域来解决</p>
</blockquote>
<h3 id="树和二叉树的转换"><a href="#树和二叉树的转换" class="headerlink" title="树和二叉树的转换"></a>树和二叉树的转换</h3><p>将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操作</p>
<p>由于树和二叉树都可以用二叉链表作存储结构，则以<strong>二叉链表作媒介</strong>可以导出树与二叉树之间的一个对应关系。</p>
<img src="/post/dd5c0739/image-20240421163742101.png" class="" title="image-20240421163742101">  

<h4 id="树转化为二叉树"><a href="#树转化为二叉树" class="headerlink" title="树转化为二叉树"></a>树转化为二叉树</h4><p>&#x3D;&#x3D;兄弟相连留长子&#x3D;&#x3D;</p>
<blockquote>
<ol>
<li>加线(兄弟连)</li>
<li>抹线（摸出除了左孩子的线）也就是去除其与其他孩子之间的线条）</li>
<li>靠地球引力就能看到二叉树了</li>
</ol>
</blockquote>
<p>树-》》》》》》》》》》》》》》》》》》》》》》》》》》》》》二叉树</p>
<img src="/post/dd5c0739/image-20240421164201774.png" class="" title="image-20240421164201774"> 

<h5 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h5><img src="/post/dd5c0739/image-20240421164339643.png" class="" title="image-20240421164339643"> 





<h4 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h4><p>&#x3D;&#x3D;二叉树变树:左孩右右连双亲去掉原来右孩线&#x3D;&#x3D;</p>
<blockquote>
<ol>
<li>加线：若p结点是双亲结点的<strong>左孩子</strong>，则将p的右孩子，右孩子的右孩子….<strong>沿分支找到的所有右孩子</strong>，都与p的双亲用线连起来（找左孩子）</li>
<li>抹线：抹掉原二叉树中双亲与右孩子之间的连线）</li>
<li>调整：万有引力调整</li>
</ol>
</blockquote>
<h5 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h5><img src="/post/dd5c0739/image-20240421164852992.png" class="" title="image-20240421164852992"> 

<h3 id="森林和二叉树的转换"><a href="#森林和二叉树的转换" class="headerlink" title="森林和二叉树的转换"></a>森林和二叉树的转换</h3><h4 id="森林转换二叉树"><a href="#森林转换二叉树" class="headerlink" title="森林转换二叉树"></a>森林转换二叉树</h4><p>&#x3D;&#x3D;森林变二叉树 树变二叉根相连&#x3D;&#x3D;</p>
<blockquote>
<p>森林转换成二叉树（二叉树与多棵树之间的关系）</p>
<p>①将各棵树分别转换成二叉树</p>
<p>②将每棵树的根结点用线相连</p>
<p>③以第一棵树根结点为二叉树的根再以根结点为轴心，顺时针旋转，构成二叉树型结构 </p>
</blockquote>
<img src="/post/dd5c0739/image-20240421165719827.png" class="" title="image-20240421165719827"> 

<h5 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h5><img src="/post/dd5c0739/image-20240421165735830.png" class="" title="image-20240421165735830"> 





<h4 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h4><p>①抹线：<strong>将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树</strong></p>
<p>②还原：将孤立的二叉树还原成树</p>
<img src="/post/dd5c0739/image-20240421170722313.png" class="" title="image-20240421170722313"> 

<h5 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h5><img src="/post/dd5c0739/image-20240421170757034.png" class="" title="image-20240421170757034"> 





<h3 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h3><p>与二叉树不同的是只有三种，树没中序，因为树可以有多个子树，根放哪里是中呢？</p>
<h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><h5 id="先根遍历"><a href="#先根遍历" class="headerlink" title="先根遍历"></a>先根遍历</h5><blockquote>
<p>若树不空,则先访问根结点，然后依次先根遍历各棵子树。</p>
</blockquote>
<h5 id="后根遍历"><a href="#后根遍历" class="headerlink" title="后根遍历"></a>后根遍历</h5><blockquote>
<p>若树不空，则先依次后根遍历各棵子树，然后访问根结点。</p>
</blockquote>
<h5 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h5><blockquote>
<p>若树不空，贝则自上而下自左至右访问树中每个结点</p>
</blockquote>
<img src="/post/dd5c0739/image-20240421172724892.png" class="" title="image-20240421172724892"> 





<h4 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h4><p>将森林看作由三部分构成：</p>
<p>1.森林中第一棵树的根结点</p>
<p>2.柔森林中第一棵树的子树森林</p>
<p>3.柔森林中其它树构成的森林。</p>
  <img src="/post/dd5c0739/image-20240421173609876.png" class="" title="image-20240421173609876"> 

<h5 id="先序遍历-2"><a href="#先序遍历-2" class="headerlink" title="先序遍历"></a>先序遍历</h5><blockquote>
<p>若森林不空，则</p>
<p>1.访问<strong>森林中第一棵树的根结点</strong>；</p>
<p>2<strong>先序遍历</strong>森林中<strong>第一棵树的子树森林</strong>；</p>
<p>3.<strong>先序遍历</strong>森林中（除第一棵树之外）<strong>其余树构成的森林</strong></p>
</blockquote>
<h5 id="中序遍历-2"><a href="#中序遍历-2" class="headerlink" title="中序遍历"></a>中序遍历</h5><blockquote>
<p>若森林不空，则</p>
<p>1.<strong>中序遍历</strong>森林中第一棵树的子树森林</p>
<p>2**.访问森林中第一棵树的根结点**;</p>
<p>3.<strong>中序遍历</strong>森林中(除第一棵树之外)其余树构成的森林即：</p>
<p><strong>依次从左至右对森林中的每一棵树进行后根遍历。</strong></p>
</blockquote>
<img src="/post/dd5c0739/image-20240421173853818.png" class="" title="image-20240421173853818"> 









<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="哈夫曼树的概念"><a href="#哈夫曼树的概念" class="headerlink" title="哈夫曼树的概念"></a>哈夫曼树的概念</h3><blockquote>
<p>判断树：描述分类过程的二叉树</p>
</blockquote>
<p>学生分数问题</p>
<img src="/post/dd5c0739/image-20240422101121813.png" class="" title="image-20240422101121813"> 

<blockquote>
<p>哈夫曼树&#x3D;最优二叉树</p>
</blockquote>
<hr>
<h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><p><strong>路径</strong>：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径。</p>
<p><strong>结点的路径长度</strong>：<strong>两结点</strong>间路径上的分支数</p>
<img src="/post/dd5c0739/image-20240422101501750.png" class="" title="image-20240422101501750"> 

<p><strong>树的路径长度</strong>:从<strong>树根</strong>到每一个结点的路径长度之和记作：TL</p>
<img src="/post/dd5c0739/image-20240422101602465.png" class="" title="image-20240422101602465"> 

<blockquote>
<p>结点树木相同的二叉树中，<strong>完全二叉树</strong>是<strong>路径长度最短</strong>的二叉树</p>
</blockquote>
<blockquote>
<p>但是路径长度最短的二叉树不一定是完全二叉树！</p>
</blockquote>
<p><strong>权(weight)<strong>：将树中结点赋给一个</strong>有着某种含义的数值</strong>则这个数值称为该<strong>结点的权</strong></p>
<p><strong>结点的带权路径长度</strong>：从<strong>根结点</strong>到<strong>该结点之间的路径长度与该结点的权的乘积</strong>。</p>
<p><strong>树的带权路径长度WPL：</strong>树中<strong>所有叶子结点</strong>的<strong>带权路径长度之和</strong></p>
<p>例子5</p>
<img src="/post/dd5c0739/image-20240422102936896.png" class="" title="image-20240422102936896"> 



<h4 id="哈夫曼树-1"><a href="#哈夫曼树-1" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><blockquote>
<p>哈夫曼树:<strong>最优树</strong>: <strong>带权路径长度</strong>最短的树</p>
<hr>
<p><strong>带权路径长度最短</strong>”是在“<strong>度相同</strong>”的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等。</p>
</blockquote>
<blockquote>
<p>哈夫曼树:<strong>最优二叉树</strong>   :带权路径长度最短的二叉树</p>
<hr>
<p>因为构造这种树的算法是由哈夫曼教授于1952年提出的,所以被称为哈夫曼树，相应的算法称为哈夫曼算法</p>
</blockquote>
<img src="/post/dd5c0739/image-20240422103413590.png" class="" title="image-20240422103413590"> 

<blockquote>
<p>权值小的距离根比较远，大的距离根近</p>
</blockquote>
<h3 id="哈夫曼树的构造算法"><a href="#哈夫曼树的构造算法" class="headerlink" title="哈夫曼树的构造算法"></a>哈夫曼树的构造算法</h3><blockquote>
<p>贪心算法：构造哈夫曼树时优先选择权值小的叶子节点</p>
</blockquote>
<p>哈夫曼算法(构造哈夫曼树的方法</p>
<blockquote>
<p>（1）根据n个给定的权值{W1，W2，，Wn}构成 n棵二叉树的森林F&#x3D;{T1， T2, ……，Tn}其中 Ti <strong>只有一个带权为 Wi的根结点。</strong></p>
<ul>
<li>构造森林全是根</li>
</ul>
<p>（2）<strong>在F中选取两棵根结点的权值最小的树</strong>作为<strong>左右子树</strong>，构造一棵新的二叉树，且设置<strong>新的二叉树的根结点的权值</strong>为其<strong>左右子树上根结点的权值之和</strong>。</p>
<ul>
<li>选用两小造新树</li>
</ul>
<p>（3）在F中删除这两棵树，同时将新得到的二叉树加入森林中。</p>
<ul>
<li>删除两小添新人</li>
</ul>
<p>（4）重复 (2)和(3)，直到森林中只有一棵树为止，这棵树即为哈夫曼树。</p>
<ul>
<li>重复2，3剩单根</li>
</ul>
</blockquote>
<img src="/post/dd5c0739/image-20240422120653452.png" class="" title="image-20240422120653452"> 

<blockquote>
<p>哈夫曼树中的结点：度数只为0或者2    没有度为1的</p>
<p>包含n个叶子节点的哈夫曼树共有2*n-1个结点</p>
<p>度为0的节点是n个</p>
<p>度为1的节点有0个</p>
<p>度为2的节点有n-1个</p>
</blockquote>
<h4 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h4><p>有5 个结点 a, b, c, d, e, 权值分别为 7,5, 5, 2, 4,构造哈夫曼树。</p>
<img src="/post/dd5c0739/image-20240422122308407.png" class="" title="image-20240422122308407"> 

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote>
<p>1、在哈夫曼算法中，<strong>初始时有n棵二叉树</strong>，要<strong>经过n-1次</strong>合并<strong>最终形成哈夫曼树。</strong></p>
<p>2、**经过 n-1 次合并产生 n-1 个新结点(度为2)**，且这n-1 个新结点都是具有两个孩子的分支结点。</p>
<p>可见：哈夫曼树中共有有 n(原来那n个度为0)+n-1(新产生的度为2的) &#x3D; 2n-1个结点，且其所有的分支结点的<strong>度均不为1。</strong></p>
</blockquote>
<h3 id="哈夫曼树构造算法的实现"><a href="#哈夫曼树构造算法的实现" class="headerlink" title="哈夫曼树构造算法的实现"></a>哈夫曼树构造算法的实现</h3><blockquote>
<p>采用顺序存储结构—–一维结构数组</p>
<p>节点类型定义</p>
</blockquote>
<img src="/post/dd5c0739/image-20240423132457118.png" class="" title="image-20240423132457118"> 

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节点类型定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data; <span class="comment">// 存储字符数据</span></span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">// 权重，即字符出现的频率</span></span><br><span class="line">    <span class="type">int</span> parent; <span class="comment">// 父节点在数组中的下标</span></span><br><span class="line">    <span class="type">int</span> lch; <span class="comment">// 左孩子在数组中的下标</span></span><br><span class="line">    <span class="type">int</span> rch; <span class="comment">// 右孩子在数组中的下标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="例子-7"><a href="#例子-7" class="headerlink" title="例子"></a>例子</h4><img src="/post/dd5c0739/image-20240423132722385.png" class="" title="image-20240423132722385"> 



<h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><blockquote>
<ol>
<li>初始化哈夫曼树数组 <code>HT[1....2n-1]</code>：设置 <code>lch</code>、<code>rch</code>、<code>parent</code> 初始值为 0。</li>
<li>输入初始的 <code>n</code> 个叶子结点：给 <code>HT[1...n]</code> 设置权重值。</li>
<li>进行以下 <code>n-1</code> 次合并，依次产生 <code>n-1</code> 个结点 <code>HT[i]</code>，其中 <code>i=n+1....2n-1</code>：<ul>
<li>在 <code>HT[1,i-1]</code> 中选择<strong>两个未被选过（即 <code>parent == 0</code> 的结点）且权重最小的两个结点</strong> <code>HT[s1]</code> 和 <code>HT[s2]</code>，其中 <code>s1</code>、<code>s2</code> 为两个最小结点的下标。</li>
<li>修改 <code>HT[s1]</code> 和 <code>HT[s2]</code> 的 <code>parent</code> 值为 <code>i</code>，即 <code>HT[s1].parent=i</code> 和 <code>HT[s2].parent=i</code>。</li>
<li>修改新产生的 <code>HT[i]</code>：<ul>
<li>设置 <code>HT[i].weight=HT[s1].weight + HT[s2].weight</code>。</li>
<li>设置 <code>HT[i].lch=s1</code>。</li>
<li>设置 <code>HT[i].rch=s2</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 续算法5.10</span></span><br><span class="line"><span class="keyword">for</span> (i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="comment">// 合并产生 n-1 个结点，构造 Huffman 树</span></span><br><span class="line">    Select(HT, i - <span class="number">1</span>, s1, s2); <span class="comment">// 在 HT[k] (1≤k≤i-1) 中选择两个其双亲域为 0，</span></span><br><span class="line">                                <span class="comment">// 且权值最小的结点，并返回它们在 HT 中的序号 s1 和 s2</span></span><br><span class="line">    HT[s1].parent = i;</span><br><span class="line">    HT[s2].parent = i; <span class="comment">// 表示从 F 中删除 s1, s2</span></span><br><span class="line">    HT[i].lch = s1;</span><br><span class="line">    HT[i].rch = s2; <span class="comment">// s1, s2 分别作为 i 的左右孩子</span></span><br><span class="line">    HT[i].weight = HT[s1].weight + HT[s2].weight; <span class="comment">// i 的权值为左右孩子权值之和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>给出</p>
<img src="/post/dd5c0739/image-20240423133027807.png" class="" title="image-20240423133027807"> 

<p>写出</p>
<img src="/post/dd5c0739/image-20240423133051385.png" class="" title="image-20240423133051385"> 





<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><h4 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h4><img src="/post/dd5c0739/image-20240423133257400.png" class="" title="image-20240423133257400"> 

<h5 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h5><blockquote>
<p>若将编码设计为<strong>长度不等的二进制编码</strong>，即让待传字符串中出现次数较多的字符采用尽可能短的编码，则转换的二进制字符串便可能减少。</p>
</blockquote>
<img src="/post/dd5c0739/image-20240423133420997.png" class="" title="image-20240423133420997"> 

<h5 id="前缀编码"><a href="#前缀编码" class="headerlink" title="前缀编码"></a>前缀编码</h5><blockquote>
<p>修正后的方法描述如下：</p>
<ol>
<li><p><strong>统计字符集</strong>中每个字符在电文中出<strong>现的平均概率</strong>，即每个字符出现的频率除以总字符数。<strong>概率越大，要求编码越短。</strong></p>
</li>
<li><p>利用哈夫曼树的特点：<strong>权值越大的叶子离根越近</strong>。将每个字符的概率值作为权值，构造哈夫曼树。这样概率越大的结点，路径越短。</p>
</li>
<li><p>在哈夫曼树的每个分支上<strong>标上0或1</strong>：<strong>结点的左分支标0，右分支标1</strong>。将<strong>从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码</strong>。</p>
</li>
</ol>
<p>利用哈夫曼树的特性，将字符的编码设计得更加高效，以实现数据的压缩。</p>
</blockquote>
<h5 id="例子-8"><a href="#例子-8" class="headerlink" title="例子"></a>例子</h5><img src="/post/dd5c0739/image-20240423133705428.png" class="" title="image-20240423133705428"> 

<img src="/post/dd5c0739/image-20240423133821256.png" class="" title="image-20240423133821256"> 



<p>【例】设组成电文的字符集D及其概率分布W为：D&#x3D;{A, B, C, D, E, F, G}</p>
<p>W&#x3D;{0.400.300.150.050.040.030.03}</p>
<img src="/post/dd5c0739/image-20240423134011200.png" class="" title="image-20240423134011200"> 

<blockquote>
<p>虽然哈夫曼树在某些情况下可能<strong>不唯一</strong>，但是<strong>它们都满足了哈夫曼编码的特性</strong>，即<strong>没有任何一个字符的编码是另一个字符编码的前缀</strong>，因此在<strong>解码时仍然能够正确还原原始数据</strong>。</p>
</blockquote>
<img src="/post/dd5c0739/image-20240423134030703.png" class="" title="image-20240423134030703">

<h4 id="哈夫曼编码的算法实现"><a href="#哈夫曼编码的算法实现" class="headerlink" title="哈夫曼编码的算法实现"></a>哈夫曼编码的算法实现</h4><blockquote>
<p>n个结点</p>
<p>结束条件：双亲为空，也就是到根节点了</p>
<p>哈夫曼树的最长路径长度等于树中叶子节点的个数减一n-1</p>
<p>哈夫曼编码是一种前缀编码 频率高的字符编码较短，频率低的字符编码较长。</p>
<p>频率越高的字符放置得越接近根节点时，哈夫曼树的形态会更加平衡</p>
</blockquote>
<img src="/post/dd5c0739/image-20240423134631270.png" class="" title="image-20240423134631270"> 

<p>倒着放，或者用栈来实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatHuffmanCode</span><span class="params">(HuffmanTree HT, HuffmanCode &amp;HC, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    HC = new <span class="type">char</span>*[n + <span class="number">1</span>]; <span class="comment">// 分配 n 个字符编码的头指针矢量</span></span><br><span class="line">    <span class="type">char</span> *cd = new <span class="type">char</span>[n]; <span class="comment">// 分配临时存放编码的动态数组空间</span></span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 编码结束符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> start = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> c = i;</span><br><span class="line">        <span class="type">int</span> f = HT[i].parent;</span><br><span class="line">        <span class="keyword">while</span> (f != <span class="number">0</span>) &#123;</span><br><span class="line">            --start; <span class="comment">// 回溯一次，start 向前指一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (HT[f].lchild == c)</span><br><span class="line">                cd[start] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 结点 c 是 f 的左孩子，则生成代码 &#x27;0&#x27;</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd[start] = <span class="string">&#x27;1&#x27;</span>; <span class="comment">// 结点 c 是 f 的右孩子，则生成代码 &#x27;1&#x27;</span></span><br><span class="line">            c = f;</span><br><span class="line">            f = HT[f].parent; <span class="comment">// 继续向上回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求出第 i 个字符的编码</span></span><br><span class="line">        HC[i] = new <span class="type">char</span>[n - start]; <span class="comment">// 为第 i 个字符串编码分配空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], &amp;cd[start]); <span class="comment">// 将求得的编码从临时空间 cd 复制到 HC 的当前行中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete[] cd; <span class="comment">// 释放临时空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义哈夫曼树的结点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data; <span class="comment">// 字符数据</span></span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">// 权重</span></span><br><span class="line">    <span class="type">int</span> parent, lchild, rchild; <span class="comment">// 双亲、左孩子、右孩子的下标</span></span><br><span class="line">&#125; HuffmanNode, *HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建哈夫曼树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateHuffmanTree</span><span class="params">(HuffmanTree &amp;HT, <span class="built_in">unordered_map</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt; &amp;freq_map)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = freq_map.size();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>; <span class="comment">// 哈夫曼树的总结点数</span></span><br><span class="line">    HT = new HuffmanNode[m + <span class="number">1</span>]; <span class="comment">// 分配存储空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化叶子结点</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;entry : freq_map) &#123;</span><br><span class="line">        HT[i].data = entry.first;</span><br><span class="line">        HT[i].weight = entry.second;</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lchild = <span class="number">0</span>;</span><br><span class="line">        HT[i].rchild = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化非叶子结点</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= m; i++) &#123;</span><br><span class="line">        HT[i].weight = <span class="number">0</span>;</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lchild = <span class="number">0</span>;</span><br><span class="line">        HT[i].rchild = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建哈夫曼树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> s1, s2;</span><br><span class="line">        <span class="type">int</span> min1 = INT_MAX, min2 = INT_MAX; <span class="comment">// 寻找权重最小的两个结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (HT[j].parent == <span class="number">0</span> &amp;&amp; HT[j].weight &lt; min1) &#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                s2 = s1;</span><br><span class="line">                min1 = HT[j].weight;</span><br><span class="line">                s1 = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HT[j].parent == <span class="number">0</span> &amp;&amp; HT[j].weight &lt; min2) &#123;</span><br><span class="line">                min2 = HT[j].weight;</span><br><span class="line">                s2 = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        HT[s1].parent = i;</span><br><span class="line">        HT[s2].parent = i;</span><br><span class="line">        HT[i].lchild = s1;</span><br><span class="line">        HT[i].rchild = s2;</span><br><span class="line">        HT[i].weight = min1 + min2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建哈夫曼编码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateHuffmanCode</span><span class="params">(HuffmanTree HT, <span class="type">char</span> **&amp;HC, <span class="built_in">unordered_map</span>&lt;<span class="type">char</span>, <span class="built_in">string</span>&gt; &amp;code_map, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    HC = new <span class="type">char</span>*[n + <span class="number">1</span>]; <span class="comment">// 分配 n 个字符编码的头指针矢量</span></span><br><span class="line">    <span class="type">char</span> *cd = new <span class="type">char</span>[n]; <span class="comment">// 分配临时存放编码的动态数组空间</span></span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 编码结束符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> start = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> c = i;</span><br><span class="line">        <span class="type">int</span> f = HT[i].parent;</span><br><span class="line">        <span class="keyword">while</span> (f != <span class="number">0</span>) &#123;</span><br><span class="line">            --start; <span class="comment">// 回溯一次，start 向前指一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (HT[f].lchild == c)</span><br><span class="line">                cd[start] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 结点 c 是 f 的左孩子，则生成代码 &#x27;0&#x27;</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd[start] = <span class="string">&#x27;1&#x27;</span>; <span class="comment">// 结点 c 是 f 的右孩子，则生成代码 &#x27;1&#x27;</span></span><br><span class="line">            c = f;</span><br><span class="line">            f = HT[f].parent; <span class="comment">// 继续向上回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求出第 i 个字符的编码</span></span><br><span class="line">        HC[i] = new <span class="type">char</span>[n - start]; <span class="comment">// 为第 i 个字符串编码分配空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], &amp;cd[start]); <span class="comment">// 将求得的编码从临时空间 cd 复制到 HC 的当前行中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将编码存入哈希表中</span></span><br><span class="line">        code_map[HT[i].data] = <span class="built_in">string</span>(HC[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete[] cd; <span class="comment">// 释放临时空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串中每个字符的频率</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt; <span class="title function_">getFrequency</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;str)</span> &#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt; freq_map;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : str) &#123;</span><br><span class="line">        freq_map[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> freq_map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串编码为哈夫曼编码</span></span><br><span class="line"><span class="built_in">string</span> <span class="title function_">encodeString</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;str, <span class="built_in">unordered_map</span>&lt;<span class="type">char</span>, <span class="built_in">string</span>&gt; &amp;code_map)</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> encoded_str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : str) &#123;</span><br><span class="line">        encoded_str += code_map[c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> encoded_str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt; freq_map = getFrequency(str);</span><br><span class="line"></span><br><span class="line">    HuffmanTree HT;</span><br><span class="line">    CreateHuffmanTree(HT, freq_map);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> **HC;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="type">char</span>, <span class="built_in">string</span>&gt; code_map;</span><br><span class="line">    CreateHuffmanCode(HT, HC, code_map, freq_map.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出哈夫曼编码</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Huffman Codes:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;entry : code_map) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Character &quot;</span> &lt;&lt; entry.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; entry.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字符串编码为哈夫曼编码</span></span><br><span class="line">    <span class="built_in">string</span> encoded_str = encodeString(str, code_map);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Encoded String: &quot;</span> &lt;&lt; encoded_str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= freq_map.size(); i++) &#123;</span><br><span class="line">        delete[] HC[i];</span><br><span class="line">    &#125;</span><br><span class="line">    delete[] HC;</span><br><span class="line">    delete[] HT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/post/dd5c0739/image-20240423140611797.png" class="" title="image-20240423140611797"> 

<h4 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结点定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="type">int</span> frequency;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">top</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新结点</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">create_node</span><span class="params">(<span class="type">char</span> data, <span class="type">int</span> frequency)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;frequency = frequency;</span><br><span class="line">    newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="keyword">struct</span> Stack* <span class="title function_">init_stack</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">stack</span> =</span> (<span class="keyword">struct</span> Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Stack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_empty</span><span class="params">(<span class="keyword">struct</span> Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="keyword">struct</span> Stack* <span class="built_in">stack</span>, <span class="keyword">struct</span> Node* node)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> StackNode));</span><br><span class="line">    newNode-&gt;node = node;</span><br><span class="line">    newNode-&gt;next = <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">pop</span><span class="params">(<span class="keyword">struct</span> Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_empty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">temp</span> =</span> <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">node</span> =</span> temp-&gt;node;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = temp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈夫曼编码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">huffman_encoding</span><span class="params">(<span class="keyword">struct</span> Node* root, <span class="type">char</span>* code, <span class="type">char</span>** codes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            codes[root-&gt;data] = strdup(code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> left_code[<span class="number">100</span>], right_code[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(left_code, code);</span><br><span class="line">        <span class="built_in">strcpy</span>(right_code, code);</span><br><span class="line">        <span class="built_in">strcat</span>(left_code, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(right_code, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        huffman_encoding(root-&gt;left, left_code, codes);</span><br><span class="line">        huffman_encoding(root-&gt;right, right_code, codes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码文本</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">encode_text</span><span class="params">(<span class="type">char</span>* text, <span class="type">char</span>** codes)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(text);</span><br><span class="line">    <span class="type">char</span>* encoded_text = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len * <span class="number">100</span>); <span class="comment">// 预留足够大的空间</span></span><br><span class="line">    encoded_text[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(encoded_text, codes[text[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> encoded_text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> text[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">int</span> frequencies[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 假设字符集为 ASCII 码，共 256 个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(text); i++) &#123;</span><br><span class="line">        frequencies[text[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建哈夫曼树并获取编码</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">root</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">stack</span> =</span> init_stack();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (frequencies[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">node</span> =</span> create_node(i, frequencies[i]);</span><br><span class="line">            push(<span class="built_in">stack</span>, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">stack</span>-&gt;top-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">node1</span> =</span> pop(<span class="built_in">stack</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">node2</span> =</span> pop(<span class="built_in">stack</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">merged_node</span> =</span> create_node(<span class="string">&#x27;\0&#x27;</span>, node1-&gt;frequency + node2-&gt;frequency);</span><br><span class="line">        merged_node-&gt;left = node1;</span><br><span class="line">        merged_node-&gt;right = node2;</span><br><span class="line">        push(<span class="built_in">stack</span>, merged_node);</span><br><span class="line">    &#125;</span><br><span class="line">    root = pop(<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取编码</span></span><br><span class="line">    <span class="type">char</span>* codes[<span class="number">256</span>] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    huffman_encoding(root, <span class="string">&quot;&quot;</span>, codes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码文本</span></span><br><span class="line">    <span class="type">char</span>* encoded_text = encode_text(text, codes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Huffman Codes:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (codes[i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c: %s\n&quot;</span>, i, codes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Encoded Text: %s\n&quot;</span>, encoded_text);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(encoded_text);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/post/dd5c0739/image-20240423140813236.png" class="" title="image-20240423140813236"> 

<h4 id="文件的编码和解码"><a href="#文件的编码和解码" class="headerlink" title="文件的编码和解码"></a>文件的编码和解码</h4><p>编码:</p>
<ol>
<li>输入各字符及其权值</li>
<li><strong>构造哈夫曼树HT[i]</strong></li>
<li>进行哈夫曼编码-HC[i]</li>
<li>查HC[j]，得到各字符的哈夫曼编码</li>
</ol>
<p>解码:</p>
<ol>
<li><strong>构造哈夫曼树</strong></li>
<li>依次读入二进制码读入0，则走向左孩子；</li>
<li>读入1，则走向右孩子</li>
<li>一旦到达某叶子时，即可译出字符</li>
<li>然后再从根出发继续译码，指导结束</li>
</ol>
<img src="/post/dd5c0739/image-20240423140046827.png" class="" title="image-20240423140046827"> 
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://017328.xyz">下完这场雨</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://017328.xyz/post/dd5c0739.html">https://017328.xyz/post/dd5c0739.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://017328.xyz" target="_blank">cout<<"金缕衣";</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/shu.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wx.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wx.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/zfb.jpg" target="_blank"><img class="post-qr-code-img" src="/img/zfb.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/ee040603.html" title="图"><img class="cover" src="/img/tu.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">图</div></div></a></div><div class="next-post pull-right"><a href="/post/1befd574.html" title="串，数组和广义表"><img class="cover" src="/img/chuan.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">串，数组和广义表</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/a444b428.html" title="排序"><img class="cover" src="/img/paixu.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-20</div><div class="title">排序</div></div></a></div><div><a href="/post/ee040603.html" title="图"><img class="cover" src="/img/tu.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-13</div><div class="title">图</div></div></a></div><div><a href="/post/33cb1151.html" title="查找"><img class="cover" src="/img/search.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-11</div><div class="title">查找</div></div></a></div><div><a href="/post/8d66b5f2.html" title="栈和队列"><img class="cover" src="/img/stack.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-15</div><div class="title">栈和队列</div></div></a></div><div><a href="/post/cadd49f.html" title="线性表"><img class="cover" src="/img/beauty8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-08</div><div class="title">线性表</div></div></a></div><div><a href="/post/6373a81a.html" title="数据结构绪论"><img class="cover" src="/img/b11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-20</div><div class="title">数据结构绪论</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTAyMS8zNTQ4Mw=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/h.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">下完这场雨</div><div class="author-info__description">椿萱并茂，棠棣同馨，松萝共倚，兰桂齐芳。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/666XRB"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/666XRB" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/xideaha?spm=1000.2115.3001.5343" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://user.qzone.qq.com/1982830095/infocenter" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:1982830095@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这里啊，这里是我的blog，分享一些学习知识。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">树和二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.1.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是树形结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.1.3.</span> <span class="toc-text">树的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA-1"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">树的表示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.1.4.</span> <span class="toc-text">有关树的基本术语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%A0%91%E5%92%8C%E6%97%A0%E5%BA%8F%E6%A0%91"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">有序树和无序树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">森林</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E6%A0%91%E7%BB%93%E6%9E%84%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">线性结构和树结构的对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">二叉树的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">思考</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%845%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%BD%A2%E6%80%81"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">二叉树的5种基本形态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%BC%95%E5%85%A5"><span class="toc-number">1.2.2.</span> <span class="toc-text">案例引入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">数据压缩问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B1%82%E8%A7%A3%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">利用二叉树求解表达式的值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">二叉树的抽象数据类型定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%E5%92%8C%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.4.</span> <span class="toc-text">二叉树的性质和存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">二叉树的性质</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%B4%A81i%E5%B1%82%E4%B8%8A%E6%9C%80%E5%A4%9A%E6%9C%89"><span class="toc-number">1.2.4.1.1.</span> <span class="toc-text">性质1i层上最多有</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%B8%BAk%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%9A"><span class="toc-number">1.2.4.1.2.</span> <span class="toc-text">深度为k的二叉树最多</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#n0-n2-1%E3%80%82"><span class="toc-number">1.2.4.1.3.</span> <span class="toc-text">n0 &#x3D; n2 + 1。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.5.</span> <span class="toc-text">特殊形式的二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">满二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.5.1.1.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">完全二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-1"><span class="toc-number">1.2.5.2.1.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">1.2.5.2.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">完全二叉树的性质</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8-4"><span class="toc-number">1.2.5.3.1.</span> <span class="toc-text">性质 4</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%81%E6%98%8E"><span class="toc-number">1.2.5.3.1.1.</span> <span class="toc-text">证明</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%B4%A85"><span class="toc-number">1.2.5.3.2.</span> <span class="toc-text">性质5</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%81%E6%98%8E-1"><span class="toc-number">1.2.5.3.2.1.</span> <span class="toc-text">证明</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.6.</span> <span class="toc-text">二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">二叉树的顺序存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.6.1.1.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="toc-number">1.2.6.1.2.</span> <span class="toc-text">完全二叉树如何存储？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="toc-number">1.2.6.1.3.</span> <span class="toc-text">一般二叉树如何存储？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.6.1.4.</span> <span class="toc-text">顺序存储还原二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.6.1.5.</span> <span class="toc-text">顺序存储的特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">二叉树的链式存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.6.2.1.</span> <span class="toc-text">二叉链表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.6.2.1.1.</span> <span class="toc-text">二叉链表存储结构</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.2.6.2.2.</span> <span class="toc-text">图形描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9F"><span class="toc-number">1.2.6.2.3.</span> <span class="toc-text">思考？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.6.2.4.</span> <span class="toc-text">三叉链表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%89%E5%8F%89%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.6.2.4.1.</span> <span class="toc-text">三叉链表存储结构</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.7.</span> <span class="toc-text">遍历二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E6%8B%AC"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">概括</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">遍历方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E7%9A%84%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">遍历方法的算法描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E7%9A%84%E6%93%8D%E4%BD%9C%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.7.4.</span> <span class="toc-text">遍历的操作定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.7.4.1.</span> <span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.7.4.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.7.4.3.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">1.2.7.4.4.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">1.2.7.4.5.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A1%A8%E7%A4%BA%E7%AE%97%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.2.7.4.6.</span> <span class="toc-text">用二叉树表示算数表达式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E5%BE%97%E5%88%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.7.5.</span> <span class="toc-text">根据遍历序列得到二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="toc-number">1.2.7.5.1.</span> <span class="toc-text">要掌握的技巧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.2.7.5.2.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.7.6.</span> <span class="toc-text">递归遍历算法的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="toc-number">1.2.7.6.1.</span> <span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="toc-number">1.2.7.6.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.7.6.3.</span> <span class="toc-text">后续遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.7.6.4.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">1.2.7.6.5.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.7.7.</span> <span class="toc-text">非递归遍历算法的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.7.8.</span> <span class="toc-text">层次遍历算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.7.8.1.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.7.8.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.8.</span> <span class="toc-text">&#x3D;&#x3D;遍历算法的应用&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">建立二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.2.8.1.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">复制二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.2.8.2.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">计算二叉树的深度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">1.2.8.3.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9%E7%9A%84%E6%80%BB%E6%95%B0"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">计算节点的总数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">1.2.8.4.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E6%80%BB%E6%95%B0"><span class="toc-number">1.2.8.5.</span> <span class="toc-text">计算叶子节点的总数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.2.8.5.1.</span> <span class="toc-text">算法实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%A0%E5%91%8A"><span class="toc-number">1.2.8.6.</span> <span class="toc-text">忠告</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.9.</span> <span class="toc-text">线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9F"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">为什么需要线索二叉树？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">1.2.9.2.</span> <span class="toc-text">线索二叉树的引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-number">1.2.9.3.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.9.4.</span> <span class="toc-text">线索二叉树的节点的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.9.4.1.</span> <span class="toc-text">线索二叉树的结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.9.5.</span> <span class="toc-text">三种线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.9.5.1.</span> <span class="toc-text">先序线索二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.9.5.2.</span> <span class="toc-text">中序线索二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.9.5.3.</span> <span class="toc-text">后续线索二叉树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%A4%B4%E8%8A%82%E7%82%B9%E7%9A%84%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.9.6.</span> <span class="toc-text">引入头节点的线索二叉树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="toc-number">1.3.</span> <span class="toc-text">树和森林</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">双亲表示法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.1.1.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-number">1.3.1.1.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">孩子链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.3.1.2.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-3"><span class="toc-number">1.3.1.2.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.3.1.2.3.</span> <span class="toc-text">结合双亲表示法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">&#x3D;&#x3D;孩子兄弟表示法&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.3.1.3.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-4"><span class="toc-number">1.3.1.3.2.</span> <span class="toc-text">特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.2.</span> <span class="toc-text">树和二叉树的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">树转化为二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A0%91"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">二叉树转换为树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-3"><span class="toc-number">1.3.2.2.1.</span> <span class="toc-text">例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.3.</span> <span class="toc-text">森林和二叉树的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">森林转换二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-4"><span class="toc-number">1.3.3.1.1.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A3%AE%E6%9E%97"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">二叉树转换为森林</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-5"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">树和森林的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E6%A0%B9%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.4.1.1.</span> <span class="toc-text">先根遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E6%A0%B9%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.4.1.2.</span> <span class="toc-text">后根遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.4.1.3.</span> <span class="toc-text">层次遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">森林的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-number">1.3.4.2.1.</span> <span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-number">1.3.4.2.2.</span> <span class="toc-text">中序遍历</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">1.4.</span> <span class="toc-text">哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">哈夫曼树的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">相关术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-1"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">哈夫曼树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">哈夫曼树的构造算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-6"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text">哈夫曼树构造算法的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-7"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">1.4.4.</span> <span class="toc-text">哈夫曼编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">问题引入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.4.1.1.</span> <span class="toc-text">解决问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%BC%96%E7%A0%81"><span class="toc-number">1.4.4.1.2.</span> <span class="toc-text">前缀编码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-8"><span class="toc-number">1.4.4.1.3.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">哈夫曼编码的算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">数组实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">栈实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81"><span class="toc-number">1.4.4.5.</span> <span class="toc-text">文件的编码和解码</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/4d9ab4ed.html" title="github图床"><img src="/img/b2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="github图床"/></a><div class="content"><a class="title" href="/post/4d9ab4ed.html" title="github图床">github图床</a><time datetime="2025-09-24T16:00:00.000Z" title="发表于 2025-09-25 00:00:00">2025-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/b34cc72c.html" title="逻辑论证1（削弱）"><img src="/img/g10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="逻辑论证1（削弱）"/></a><div class="content"><a class="title" href="/post/b34cc72c.html" title="逻辑论证1（削弱）">逻辑论证1（削弱）</a><time datetime="2025-03-27T11:21:42.000Z" title="发表于 2025-03-27 19:21:42">2025-03-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/dbde71d8.html" title="组合排列"><img src="/img/g9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="组合排列"/></a><div class="content"><a class="title" href="/post/dbde71d8.html" title="组合排列">组合排列</a><time datetime="2025-03-26T01:18:37.000Z" title="发表于 2025-03-26 09:18:37">2025-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d9a2d074.html" title="翻译推理"><img src="/img/g8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="翻译推理"/></a><div class="content"><a class="title" href="/post/d9a2d074.html" title="翻译推理">翻译推理</a><time datetime="2025-03-25T01:30:22.000Z" title="发表于 2025-03-25 09:30:22">2025-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/ef3d0435.html" title="判断推理_定义判断"><img src="/img/g7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="判断推理_定义判断"/></a><div class="content"><a class="title" href="/post/ef3d0435.html" title="判断推理_定义判断">判断推理_定义判断</a><time datetime="2025-03-19T11:12:43.000Z" title="发表于 2025-03-19 19:12:43">2025-03-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025  <i id="heartbeat" class="fa fas fa-heartbeat"></i> 下完这场雨</div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!<br> <img src="https://haiyong.site/img/icp.png"> <a href="https://beian.miit.gov.cn/#/Integrated/index"  style="color:#87ceeb" target="_blank">豫ICP备2024090942号-1</a></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'VbfV1mFYBGUNtUKD0cr1qUls-gzGzoHsz',
      appKey: 'LssvKROPsftMFNCa4j2AnVL8',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Valine' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://VbfV1mFY.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'VbfV1mFYBGUNtUKD0cr1qUls-gzGzoHsz',
        "X-LC-Key": 'LssvKROPsftMFNCa4j2AnVL8',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="592262222" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="false" muted></div><script src="http://cdn.bootcss.com/pace/1.0.2/pace.min.js" async></script><script src="/js/weather.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="random" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":60,"height":120,"hOffset":20,"vOffset":-20},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>