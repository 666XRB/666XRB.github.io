<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java面向对象核心 | cout&lt;&lt;&quot;金缕衣&quot;;</title><meta name="author" content="下完这场雨"><meta name="copyright" content="下完这场雨"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="类&amp;对象 创建类：  使用 class 关键字声明类。 类名的命名应该符合标识符的规范，&#x3D;&#x3D;以大写字母开头，采用驼峰命名法。&#x3D;&#x3D;  public class MyClass &amp;#123;    &#x2F;&#x2F; 类的成员变量和方法&amp;#125;  构造方法：  构造方法是一种特殊的方法，用于&#x3D;&#x3D;初始化对象的状态。&#x3D;&#x3D; &amp;#x">
<meta property="og:type" content="article">
<meta property="og:title" content="java面向对象核心">
<meta property="og:url" content="https://017328.xyz/post/cd36ea51.html">
<meta property="og:site_name" content="cout&lt;&lt;&quot;金缕衣&quot;;">
<meta property="og:description" content="类&amp;对象 创建类：  使用 class 关键字声明类。 类名的命名应该符合标识符的规范，&#x3D;&#x3D;以大写字母开头，采用驼峰命名法。&#x3D;&#x3D;  public class MyClass &amp;#123;    &#x2F;&#x2F; 类的成员变量和方法&amp;#125;  构造方法：  构造方法是一种特殊的方法，用于&#x3D;&#x3D;初始化对象的状态。&#x3D;&#x3D; &amp;#x">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://017328.xyz/img/beauty15.jpg">
<meta property="article:published_time" content="2023-11-28T13:55:52.000Z">
<meta property="article:modified_time" content="2023-11-29T07:06:33.406Z">
<meta property="article:author" content="下完这场雨">
<meta property="article:tag" content="java语法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://017328.xyz/img/beauty15.jpg"><link rel="shortcut icon" href="/img/icon.png"><link rel="canonical" href="https://017328.xyz/post/cd36ea51.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 下完这场雨","link":"链接: ","source":"来源: cout<<\"金缕衣\";","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java面向对象核心',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-29 15:06:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script src="//code.tidio.co/xysdkaby5vgv2dt8e9zgdqsu6wh59g43.js" async></script><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/mystyle.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4770397_jz6ucve7mog.css<link rel="stylesheet" href="/css/ancientPoetry.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/h.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Video</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于帅比</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/beauty15.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="cout&lt;&lt;&quot;金缕衣&quot;;"><img class="site-icon" src="/img/icon.png"/><span class="site-name">cout&lt;&lt;&quot;金缕衣&quot;;</span></a></span><div id="wearher"></div><div id="tp-weather-widget"></div><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Video</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于帅比</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java面向对象核心</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-28T13:55:52.000Z" title="发表于 2023-11-28 21:55:52">2023-11-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-29T07:06:33.406Z" title="更新于 2023-11-29 15:06:33">2023-11-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">28.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>103分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java面向对象核心"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="类-对象"><a href="#类-对象" class="headerlink" title="类&amp;对象"></a>类&amp;对象</h1><ol>
<li><p><strong>创建类：</strong></p>
<ul>
<li>使用 <code>class</code> 关键字声明类。</li>
<li>类名的命名应该符合标识符的规范，&#x3D;&#x3D;以大写字母开头，采用驼峰命名法。&#x3D;&#x3D;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 类的成员变量和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>构造方法：</strong></p>
<ul>
<li>构造方法是一种特殊的方法，用于&#x3D;&#x3D;初始化对象的状态。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;构造方法的名称与类名相同，没有返回类型（包括 <code>void</code>）。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;构造方法可以有参数，这些参数用于初始化对象的属性。&#x3D;&#x3D;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 构造方法的初始化逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 带参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造方法的初始化逻辑，使用参数初始化成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实例化对象：</strong></p>
<ul>
<li>使用 <code>new</code> 关键字创建类的实例。</li>
<li>构造方法在对象创建时自动调用，用于初始化对象的状态。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">myObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(); <span class="comment">// 调用无参构造方法</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">anotherObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(<span class="string">&quot;John&quot;</span>, <span class="number">25</span>); <span class="comment">// 调用带参构造方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>默认构造方法：</strong></p>
<ul>
<li>&#x3D;&#x3D;如果类没有显式定义构造方法，<strong>Java会提供一个默认的无参构造方法。</strong>&#x3D;&#x3D;空实现！</li>
<li>如果类定义了带参构造方法，但没有定义无参构造方法，那么在创建对象时必须使用带参构造方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 默认的无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 默认构造方法的初始化逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol>
<li><p>当提供了一个有参构造函数时，Java编译器不再自动生成默认的无参构造函数。</p>
</li>
<li><p>如果你的类中没有显式提供任何构造函数，Java编译器会自动生成一个默认的无参构造函数，</p>
</li>
<li><p>但是&#x3D;&#x3D;一旦提供了有参构造函数，这个默认的无参构造函数就不再自动生成了。&#x3D;&#x3D;</p>
</li>
</ol>
<p>所以，如果你提供了一个有参构造函数，而又想要保留默认的无参构造函数，需要显式提供这个无参构造函数。</p>
<p>也是最推荐的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 有参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> parameter)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造函数实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式提供的无参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 构造函数实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这确保了在创建对象时，你既可以使用有参构造函数，也可以使用无参构造函数。</p>
<h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a><a name="权限">权限修饰符</a></h2><blockquote>
<p>访问权限修饰符是按照从最大权限到最小权限的顺序排列的。下面是权限从高到低的顺序：</p>
<ol>
<li><p><strong>public：</strong></p>
<ul>
<li>公共访问级别，对所有类都是可见的。</li>
</ul>
</li>
<li><p><strong>protected：</strong></p>
<ul>
<li>受保护访问级别，对同一包内的类和所有子类可见。</li>
</ul>
</li>
<li><p><strong>默认（包级别，默认级别）：</strong></p>
<ul>
<li>如果没有指定任何访问修饰符，默认为包级别，对同一包内的类可见。</li>
</ul>
</li>
<li><p><strong>private：</strong></p>
<ul>
<li>私有访问级别，仅对同一类可见。</li>
<li><code>public &gt; protected &gt; 默认 &gt; private</code></li>
</ul>
</li>
</ol>
</blockquote>
<ul>
<li>&#x3D;&#x3D;protect扩大了private的权限，但是又不能达到public的权利&#x3D;&#x3D;</li>
</ul>
<h2 id="不同权限的访问能力"><a href="#不同权限的访问能力" class="headerlink" title="不同权限的访问能力"></a>不同权限的访问能力</h2><table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>默认</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一类中</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>同一包中的类</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>不同包的子类</td>
<td>√</td>
<td>&#x3D;&#x3D;√&#x3D;&#x3D;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>不同包中的无关类</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>可见，public具有最大权限。private则是最小权限。</p>
<p>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p>
<ul>
<li>成员变量使用<code>private</code> ，隐藏细节。</li>
<li>构造方法使用<code> public</code> ，方便创建对象。</li>
<li>成员方法使用<code>public</code> ，方便调用方法。</li>
</ul>
<blockquote>
<p>小贴士：不加权限修饰符，就是默认权限</p>
</blockquote>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>封装是面向对象编程中的一项重要原则，它指的是&#x3D;&#x3D;将类的实现细节隐藏起来&#x3D;&#x3D;，通过公共接口提供对类的访问。</p>
<ol>
<li><p><strong>核心知识点：</strong></p>
<ul>
<li><strong>访问修饰符：</strong> 使用 <code>private</code>、<code>public</code>、<code>protected</code> 等关键字来控制成员的访问权限。</li>
<li><strong>Getter 和 Setter 方法：</strong> 提供公共的方法用于获取（Getter）和设置（Setter）私有成员的值。</li>
<li><strong>封装的目的：</strong> &#x3D;&#x3D;<strong>隐藏类的内部实现细节，提供更安全、可控的访问方式</strong>，降低类的耦合度。&#x3D;&#x3D;</li>
</ul>
</li>
<li><p><strong>案例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">// 私有成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String model;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> year;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String model, <span class="type">int</span> year)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.model = model;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter 方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getModel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getYear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setModel</span><span class="params">(String model)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.model = model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setYear</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加一些逻辑，确保年份在合理范围内</span></span><br><span class="line">        <span class="keyword">if</span> (year &gt;= <span class="number">1900</span> &amp;&amp; year &lt;= <span class="number">2023</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.year = year;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Invalid year&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Car</code> 类的成员变量 <code>model</code> 和 <code>year</code> 被声明为私有</p>
<p>通过公共的 Getter 和 Setter 方法提供对它们的访问。</p>
<p>这样，外部代码无法直接访问这些变量，必须通过类提供的公共接口进行访问和修改。</p>
<p>这种封装的方式可以保护类的内部状态，使得类的实现细节可以更灵活地变化，而不影响外部使用者。</p>
</li>
</ol>
<h1 id="继承static★★"><a href="#继承static★★" class="headerlink" title="&#x3D;&#x3D;继承static★★&#x3D;&#x3D;"></a>&#x3D;&#x3D;继承static★★&#x3D;&#x3D;</h1><ul>
<li><input disabled="" type="checkbox"> 能够掌握static关键字修饰的变量调用方式</li>
<li><input disabled="" type="checkbox"> 能够掌握static关键字修饰的方法调用方式</li>
<li><input disabled="" type="checkbox"> 知道静态代码块的格式和应用场景</li>
<li><input disabled="" type="checkbox"> 能够写出类的继承格式</li>
<li><input disabled="" type="checkbox"> 能够说出继承的特点</li>
<li><input disabled="" type="checkbox"> 能够区分this和super的作用</li>
<li><input disabled="" type="checkbox"> 能够说出方法重写的概念</li>
<li><input disabled="" type="checkbox"> 能够说出方法重写的注意事项</li>
</ul>
<blockquote>
<p>在Java中，类的加载是在程序运行时由Java虚拟机（JVM）负责的过程。</p>
<p>类加载包括三个步骤：加载（Loading）、链接（Linking），和初始化（Initialization）</p>
<ul>
<li><p><strong>加载（Loading）：</strong> 加载阶段是指将类的字节码加载到内存中。这个过程是在类被首次引用时发生的，例如通过 <code>new</code> 关键字创建对象、调用静态成员等。加载阶段，&#x3D;&#x3D;类的字节码被加载到方法区&#x3D;&#x3D;</p>
</li>
<li><p><strong>链接（Linking）：</strong> 链接阶段包括验证（Verification）、准备（Preparation），和解析（Resolution）。这些步骤在加载之后进行。</p>
</li>
<li><p><strong>初始化（Initialization）：</strong> &#x3D;&#x3D;初始化阶段是在类加载之后，当类首次被主动使用时发生的&#x3D;&#x3D;。在这个阶段，静态变量被赋予初始值，静态块被执行。</p>
</li>
</ul>
<p>类的加载时机早于对象的实例化。当类加载时，其中的静态成员（静态变量和静态方法）会被加载到内存中。静态方法可以在对象实例化之前被调用，因为它们属于类而不是对象。</p>
<p>当说“静态方法在对象实例化之前就被调用”时，是指在类的加载过程中，<strong>静态方法可以被调用</strong>，而不需要等到对象实例化。</p>
<p>这也是为什么在静态方法中无法直接访问非静态成员（实例变量或实例方法）的原因，因为在静态方法被调用的时候，<strong>可能并没有对象实例化</strong>，而非静态成员是需要对象实例存在才能访问的。</p>
</blockquote>
<h1 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h1><p>&#x3D;&#x3D;<strong>this出现在构造方法中，代表构造方法正在初始化的那个对象</strong>。&#x3D;&#x3D;</p>
<p><code>this</code> 是一个关键字，代表&#x3D;&#x3D;当前对象的引用&#x3D;&#x3D;。</p>
<ol>
<li><p><strong>表示当前对象：</strong></p>
<ul>
<li><code>this</code> 用于在类的实例方法中引用&#x3D;&#x3D;当前对象。&#x3D;&#x3D;</li>
<li>可以使用 <code>this</code> 来访问当前对象的实例变量和方法。</li>
</ul>
</li>
<li><p><strong>解决命名冲突：</strong></p>
<ul>
<li>在方法中，如果存在局部变量和实例变量或方法参数和实例变量同名，可以使用 <code>this</code> 来区分。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用this解决命名冲突</span></span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在构造方法中调用其他构造方法：</strong></p>
<ul>
<li>可以在一个构造方法中使用 <code>this</code> 调用同一个类的其他构造方法，以避免代码重复。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Example</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用另一个构造方法</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Example</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>作为返回值：</strong></p>
<ul>
<li>在方法中，可以使用 <code>this</code> 作为返回值，以支持&#x3D;&#x3D;链式调用。&#x3D;&#x3D;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Example <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>类的定义格式如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名 &#123;</span><br><span class="line">    <span class="comment">// 1.成员变量（属性）</span></span><br><span class="line">    <span class="comment">// 2.成员方法 (行为) </span></span><br><span class="line">    <span class="comment">// 3.构造方法 （初始化类的对象数据的）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 1.成员变量</span></span><br><span class="line">    <span class="keyword">public</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> sex ; <span class="comment">// &#x27;男&#x27;  &#x27;女&#x27;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;this代表所在类的当前对象的引用（地址值），即代表当前对象。&#x3D;&#x3D;</p>
<h3 id="this关键字的应用"><a href="#this关键字的应用" class="headerlink" title="this关键字的应用"></a>this关键字的应用</h3><h3 id="用于普通的gettter与setter方法"><a href="#用于普通的gettter与setter方法" class="headerlink" title="用于普通的gettter与setter方法"></a>用于普通的gettter与setter方法</h3><p>this出现在实例方法中，谁调用这个方法（哪个对象调用这个方法），this就代表谁（this就代表哪个对象）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      	<span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">0</span> &amp;&amp; age &lt; <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄非法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Static关键字-内存区域"><a href="#Static关键字-内存区域" class="headerlink" title="Static关键字 &amp;内存区域"></a>Static关键字 &amp;内存区域</h1><h2 id="2-1-static概述"><a href="#2-1-static概述" class="headerlink" title="2.1 static概述"></a>2.1 static概述</h2><p><code>static</code> 是Java中的关键字，用于声明静态成员（静态变量、静态方法）以及静态代码块.</p>
<ul>
<li><p><strong>作用：</strong> &#x3D;&#x3D;<code>static</code> 关键字用于声明类级别的成员&#x3D;&#x3D;，与类的实例无关，属于<strong>类本身</strong>。</p>
</li>
<li><p><strong>静态变量：</strong> 使用 <code>static</code> 声明的变量是类变量，被所有类的实例共享。在类加载时初始化，只初始化一次。</p>
</li>
<li><p><strong>静态方法：</strong> 使用 <code>static</code> 声明的方法是类方法，可以通过类名直接调用，无需创建类的实例。</p>
</li>
<li><p><strong>静态代码块：</strong> 使用 <code>static</code> 声明的代码块，在类加载时执行，用于一次性的初始化工作。</p>
</li>
<li><p><strong>访问方式：</strong> 静态成员通过类名直接访问，强调了与类关联而不是与实例关联。</p>
</li>
<li><p><strong>共享性质：</strong> 静态成员被所有实例共享，可以用于表示全局信息或执行一次性的初始化操作。</p>
</li>
</ul>
<p>&#x3D;&#x3D;被static修饰的成员是<strong>属于类</strong>的是放在静态区中，&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;没有static修饰的成员变量和方法则是<strong>属于对象</strong>的。&#x3D;&#x3D;</p>
<h2 id="2-2-定义格式和使用"><a href="#2-2-定义格式和使用" class="headerlink" title="2.2 定义格式和使用"></a>2.2 定义格式和使用</h2><p>static是静态的意思。 static可以修饰成员变量或者修饰方法。</p>
<p>&#x3D;&#x3D;有static修饰成员变量，说明这个成员变量是属于<strong>类</strong>的，这个成员变量称为<strong>类变量</strong>或者<strong>静态成员变量</strong>。&#x3D;&#x3D;</p>
<blockquote>
<p> 直接用  类名访问即可。</p>
<p> 因为类只有一个，所以静态成员变量在内存区域中也只存在一份。</p>
<p> 所有的对象都可以共享这个变量。</p>
</blockquote>
<p><strong>如何使用呢</strong></p>
<p>例如现在我们需要定义传智全部的学生类，那么这些学生类的对象的学校属性应该都是“传智”，这个时候我们可以把这个属性定义成static修饰的静态成员变量。</p>
<p>和final一样习惯放在修饰符后面</p>
<p><strong>定义格式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> 数据类型 变量名;</span><br><span class="line">修饰符 <span class="keyword">static</span> 数据类型 变量名 = 初始值;</span><br></pre></td></tr></table></figure>

<h2 id="2-3静态成员的访问方式："><a href="#2-3静态成员的访问方式：" class="headerlink" title="2.3静态成员的访问方式："></a>2.3静态成员的访问方式：</h2><p>静态成员（静态变量和静态方法）&#x3D;&#x3D;可以通过类名直接访问，无需创建类的实例。&#x3D;&#x3D;</p>
<blockquote>
<p>类名.静态成员</p>
<p>实例化的对象.静态成员</p>
</blockquote>
<ol>
<li><p><strong>访问静态变量：</strong></p>
<ul>
<li>使用类名直接访问静态变量，格式为 <code>ClassName.staticVariable</code>。</li>
<li>并不是推荐使用对象引用来访问静态变量，但这的方式会给人一种误导，让人以为这是一个实例变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVariable</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 访问静态变量</span></span><br><span class="line">        System.out.println(Example.staticVariable);</span><br><span class="line">        <span class="comment">// 也可以使用对象引用来访问，但不推荐</span></span><br><span class="line">        <span class="type">Example</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        System.out.println(instance.staticVariable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>访问静态方法：</strong></p>
<ul>
<li>使用类名直接调用静态方法，格式为 <code>ClassName.staticMethod()</code>。</li>
<li>与静态变量一样，也可以使用对象引用来调用静态方法，但这同样不是推荐的方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a static method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用静态方法</span></span><br><span class="line">        Example.staticMethod();</span><br><span class="line">        <span class="comment">// 也可以使用对象引用来调用，但不推荐</span></span><br><span class="line">        <span class="type">Example</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        instance.staticMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>&#x3D;&#x3D;<strong>实例成员变量属于每个对象，必须创建类的对象才可以访问</strong>&#x3D;&#x3D;</p>
<h2 id="2-4内存区域划分"><a href="#2-4内存区域划分" class="headerlink" title="2.4内存区域划分"></a>2.4内存区域划分</h2><blockquote>
<p>内存可以分为几个不同的区域，主要包括</p>
<p>方法区 、 堆（Heap）、栈（Stack）、本地方法栈、和程序计数器</p>
<ol>
<li><p><strong>方法区（Method Area）：</strong></p>
<ul>
<li>存储类的元信息，如类名、访问修饰符、字段信息、方法信息等。</li>
<li>所有线程共享，用于存储被加载的类信息。</li>
<li>包括静态变量、常量，也包括运行时常量池。</li>
</ul>
</li>
<li><p><strong>堆（Heap）：</strong></p>
<ul>
<li>存储对象实例，包括通过 <code>new</code> 关键字创建的对象。</li>
<li>所有线程共享，是垃圾收集器管理的主要区域。</li>
<li>在堆中，会分为新生代和老年代，用于实现不同的垃圾回收算法。</li>
</ul>
</li>
<li><p><strong>栈（Stack）：</strong></p>
<ul>
<li>存储方法调用的&#x3D;&#x3D;局部变量、操作数栈、方法出口&#x3D;&#x3D;等信息。</li>
<li>每个线程都有一个独立的栈，用于保存线程的局部变量。</li>
<li>栈帧（Stack Frame）在方法调用和返回时被压入和弹出。</li>
</ul>
</li>
<li><p><strong>本地方法栈（Native Method Stack）：</strong></p>
<ul>
<li>用于支持本地方法，即使用 native 关键字声明的方法。</li>
<li>与栈类似，但是为本地方法服务。</li>
</ul>
</li>
<li><p><strong>程序计数器（Program Counter Register）：</strong></p>
<ul>
<li>记录当前线程执行的字节码指令的地址。</li>
<li>每个线程都有一个独立的程序计数器，用于线程切换和恢复执行状态。</li>
</ul>
</li>
</ol>
<p>此外，可以根据不同的角度，将方法区、堆、栈这三个区域合称为 Java 虚拟机的运行时数据区。</p>
<p>&#x3D;&#x3D;<strong>静态区</strong>一般指的是方法区，其中包括静态变量和常量。&#x3D;&#x3D;</p>
</blockquote>
<h2 id="2-5static内存图解释"><a href="#2-5static内存图解释" class="headerlink" title="2.5static内存图解释"></a>2.5static内存图解释</h2><img src="/post/cd36ea51/image-20231128200145499-17012414461171.png" class="" title="image-20231128200145499">

<p>通过一个简单的静态成员的例子来解释Java中的静态内存图，并说明其中涉及的主要内存区域，特别是堆内存的变化。我们考虑一个包<strong>含静态变量和静态方法的类</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryExample</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVariable</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method is called.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 在main方法中访问静态变量和调用静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Static variable: &quot;</span> + staticVariable);</span><br><span class="line">        staticMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>加载类：</strong></p>
<ul>
<li>当程序启动时，Java虚拟机（JVM）负责加载 <code>MemoryExample</code> 类。</li>
<li>静态变量 <code>staticVariable</code> 和静态方法 <code>staticMethod</code> 被加载到&#x3D;&#x3D;方法区（Method Area）。&#x3D;&#x3D;</li>
</ul>
</li>
<li><p><strong>分配内存：</strong></p>
<ul>
<li>静态变量 <code>staticVariable</code> 被分配内存，并初始化为默认值（在这个例子中是0）。</li>
<li>方法区保存静态方法 <code>staticMethod</code> 的字节码。</li>
</ul>
</li>
<li><p><strong>初始化：</strong></p>
<ul>
<li>静态变量 <code>staticVariable</code> 被初始化为赋予的值（在这个例子中是10）。</li>
<li>&#x3D;&#x3D;类的静态块（如果有的话）在这个阶段被执行。&#x3D;&#x3D;</li>
</ul>
</li>
<li><p><strong>调用main方法：</strong></p>
<ul>
<li><code>main</code> 方法被调用，程序开始执行。</li>
<li>在 <code>main</code> 方法中访问静态变量和调用静态方法。</li>
</ul>
</li>
<li><p><strong>访问静态变量：</strong></p>
<ul>
<li>在 <code>main</code> 方法中访问静态变量 <code>staticVariable</code>，这时候它的值是10。</li>
</ul>
</li>
<li><p><strong>调用静态方法：</strong></p>
<ul>
<li>在 <code>main</code> 方法中调用静态方法 <code>staticMethod</code>，该方法被执行，输出 “Static method is called.”。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>方法区：</strong> 存储类的字节码、静态变量、静态方法等。</li>
<li><strong>堆内存：</strong> &#x3D;&#x3D;用于存储对象实例&#x3D;&#x3D;</li>
<li><strong>栈内存：</strong> &#x3D;&#x3D;用于存储方法调用的局部变量和方法调用信息&#x3D;&#x3D;。在这个例子中，<code>main</code> 方法的调用会在栈上创建一个帧。</li>
</ul>
<h2 id="static的注意事项"><a href="#static的注意事项" class="headerlink" title="static的注意事项"></a>static的注意事项</h2><p> <code>static</code> 使用的主要注意事项：</p>
<ol>
<li><p><strong>静态成员属于类：</strong></p>
<ul>
<li>静态成员（变量或方法）属于整个类，而不是某个特定的实例。这意味着它被所有实例共享。</li>
</ul>
</li>
<li><p><strong>静态成员在类加载时初始化：</strong></p>
<ul>
<li>静态成员在类加载时被初始化，只会初始化一次。它们在类的生命周期内保持不变。</li>
</ul>
</li>
<li><p><strong>无法直接访问非静态成员：</strong></p>
<ul>
<li>&#x3D;&#x3D;在静态方法中<strong>不能直接访问非静态成员</strong>（实例变量或实例方法），因为<strong>静态方法在对象实例化之前就被调用</strong>。&#x3D;&#x3D;</li>
</ul>
</li>
<li><p><strong>静态方法中不能使用this关键字：</strong></p>
<ul>
<li>在静态方法中不能使用 <code>this</code> 关键字，因为 <code>this</code> 代表对象实例，而静态方法没有隶属于特定实例。</li>
</ul>
</li>
<li><p><strong>静态方法中只能调用静态成员：</strong></p>
<ul>
<li>静态方法中只能直接调用静态成员，不能直接调用非静态成员。</li>
</ul>
</li>
<li><p><strong>静态块的执行时机：</strong></p>
<ul>
<li>静态块在类加载时执行，用于进行一次性的初始化操作，如对静态变量的赋值。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> staticVariable;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 静态块，在类加载时执行</span></span><br><span class="line">        staticVariable = <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法只能直接访问静态成员</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Static variable: &quot;</span> + staticVariable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p><strong>静态变量的生命周期：</strong></p>
<ul>
<li>静态变量的生命周期长于对象实例，它们存在于整个应用程序的运行期间。</li>
</ul>
</li>
<li><p><strong>谨慎使用静态变量：</strong></p>
<ul>
<li>虽然静态变量可以在多个对象实例之间共享信息，但过度使用静态变量可能导致全局状态和不易维护的代码。</li>
</ul>
</li>
</ol>
<h2 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5&#x3D;&#x3D;小结&#x3D;&#x3D;"></a>2.5&#x3D;&#x3D;小结&#x3D;&#x3D;</h2><p>1.当 <code>static</code> 修饰成员变量或者成员方法时，该变量称为<strong>静态变量</strong>，该方法称为<strong>静态方法</strong>。</p>
<p>&#x3D;&#x3D;该类的每个对象都<strong>共享</strong>同一个类的静态变量和静态方法。&#x3D;&#x3D;</p>
<p>2.无static修饰的成员变量或者成员方法，称为<strong>实例变量，实例方法</strong>，</p>
<p>&#x3D;&#x3D;实例变量和实例方法必须创建类的对象，然后通过对象来访问。&#x3D;&#x3D;</p>
<p>3.static修饰的成员属于类，会存储在静态区</p>
<p>&#x3D;&#x3D;随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。&#x3D;&#x3D;</p>
<p>存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。</p>
<p>&#x3D;&#x3D;它优先于对象存在，所以，可以被所有对象共享。&#x3D;&#x3D;</p>
<p>4.无static修饰的成员，是属于对象，对象有多少个，他们就会出现多少份。所以<strong>必须由对象调用。</strong></p>
<blockquote>
<p>用于定义<strong>静态成员</strong>和<strong>静态方法</strong></p>
<ol>
<li><p><strong>静态变量（Static Variables）：</strong></p>
<ul>
<li>静态变量是使用 static 关键字声明的类级别变量，也称为&#x3D;&#x3D;类变量&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;所有该类的对象共享同一个静态变量的值。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;静态变量在类加载时被初始化，且只初始化一次。&#x3D;&#x3D;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticvar</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态方法（Static Methods）：</strong></p>
<ul>
<li>静态方法使用 static 关键字定义，&#x3D;&#x3D;属于整个类而不是类的实例。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;<strong>静态方法不能直接访问非静态成员</strong>，因为它们在对象实例化之前就已经存在&#x3D;&#x3D;。</li>
<li>静态成员先存在，但是非静态成员是对象实例化之后才有的，实例化之前是访问不了的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a static method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态块（Static Block）：</strong></p>
<ul>
<li>静态块是使用 static 关键字定义的代码块，在类加载时执行，用于执行静态变量的初始化或其他一次性的初始化操作。</li>
<li>一个在类加载时自动执行的代码段，它允许你在类加载过程中执行一些特定的逻辑。</li>
<li>用法:</li>
<li><strong>初始化静态变量：</strong> 将静态块用于初始化静态变量，确保在类加载时它们已经被正确地设置。</li>
<li><strong>加载静态资源：</strong> 如果你的类需要加载一些静态资源，例如配置文件、数据库驱动程序等，静态块可以用于执行这些加载操作。</li>
<li><strong>执行复杂的初始化逻辑：</strong> 有时，初始化逻辑可能涉及到一些复杂的计算或初始化步骤，可以将这些逻辑放在静态块中。****</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> staticVariable;</span><br><span class="line">    <span class="comment">// 静态块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 执行一次性的初始化工作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Static block is executed.&quot;</span>);</span><br><span class="line">        staticVariable = <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 在 main 方法中访问静态变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Static variable: &quot;</span> + staticVariable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态导入（Static Import）：</strong></p>
<ul>
<li>静态导入允许直接访问一个类的静态成员，而不需要使用类名来限定。</li>
<li>可以使用 <code>import static</code> 语句来实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"><span class="comment">//import java.lang.Math.*;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(PI);</span><br><span class="line">        <span class="comment">//Math.PI现在可以直接PI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态内部类（Static Inner Class）：</strong></p>
<ul>
<li>静态内部类是在类内部使用 static 修饰的内部类。</li>
<li>静态内部类不依赖于外部类的实例，可以直接通过类名访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        JFrame j=<span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;大苏打&quot;</span>);  </span><br><span class="line">        JButton jb=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;an1&quot;</span>);</span><br><span class="line">        <span class="comment">//内部类</span></span><br><span class="line">        jb.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;aaghah&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><h3 id="3-1-1-引入"><a href="#3-1-1-引入" class="headerlink" title="3.1.1 引入"></a>3.1.1 引入</h3><p>假如我们要定义如下类:<br>学生类,老师类和工人类，分析如下。</p>
<ol>
<li><p>学生类<br>属性:姓名,年龄<br>行为:吃饭,睡觉</p>
</li>
<li><p>老师类<br>属性:姓名,年龄，薪水<br>行为:吃饭,睡觉，教书</p>
</li>
<li><p>班主任<br>属性:姓名,年龄，薪水<br>行为:吃饭,睡觉，管理</p>
</li>
</ol>
<p>如果我们定义了这三个类去开发一个系统，那么这三个类中&#x3D;&#x3D;就存在大量重复的信息&#x3D;&#x3D;（属性:姓名，年龄。行为：吃饭，睡觉）。这样就导致了<strong>相同代码大量重复</strong>，代码显得很臃肿和冗余，那么如何解决呢？</p>
<p>&#x3D;&#x3D;假如多个类中存在相同属性和行为时，我们可以将这些内容抽取到单独一个类中&#x3D;&#x3D;，那么多个类无需再定义这些属性和行为，只要<strong>继承</strong>那一个类即可。如图所示：</p>
<img src="/post/cd36ea51/1-17012414461172.jpg" class="">

<p>其中，多个类可以称为<strong>子类</strong>，单独被继承的那一个类称为<strong>父类</strong>、<strong>超类（superclass）</strong>或者<strong>基类</strong>。</p>
<p>父&#x2F;超&#x2F;基</p>
<h3 id="3-1-2-继承的含义"><a href="#3-1-2-继承的含义" class="headerlink" title="3.1.2 继承的含义"></a>3.1.2 继承的含义</h3><p>继承描述的是事物之间的所属关系，这种关系是：<code>is-a</code> 的关系。</p>
<p>例如，兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。</p>
<blockquote>
<p><strong>继承</strong>：就是子类继承父类的<strong>属性</strong>和<strong>行为</strong>，&#x3D;&#x3D;使得子类对象可以直接具有与父类相同的属性、相同的行为。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;子类可以直接访问父类中的<strong>非私有</strong>的属性和行为。&#x3D;&#x3D;</p>
</blockquote>
<h3 id="3-1-3-继承的好处"><a href="#3-1-3-继承的好处" class="headerlink" title="3.1.3 继承的好处"></a>3.1.3 继承的好处</h3><ol>
<li>提高<strong>代码的复用性</strong>（减少代码冗余，相同代码重复利用）。</li>
<li>使类与类之间产生了关系。</li>
</ol>
<h2 id="3-2-继承的格式"><a href="#3-2-继承的格式" class="headerlink" title="3.2 继承的格式"></a>3.2 继承的格式</h2><p>通过 <code>extends</code> 关键字，可以声明一个子类继承另外一个父类，定义格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;<strong>需要注意：Java是单继承的，一个类只能继承一个直接父类，跟现实世界很像，但是Java中的子类是更加强大的。</strong>&#x3D;&#x3D;</p>
<h2 id="3-3-继承案例"><a href="#3-3-继承案例" class="headerlink" title="3.3 继承案例"></a>3.3 继承案例</h2><h3 id="3-3-1-案例"><a href="#3-3-1-案例" class="headerlink" title="3.3.1 案例"></a>3.3.1 案例</h3><p>请使用继承定义以下类:</p>
<ol>
<li>学生类<br>属性:姓名,年龄<br>行为:吃饭,睡觉</li>
<li>老师类<br>属性:姓名,年龄，薪水<br>行为:吃饭,睡觉，教书</li>
<li>班主任<br>属性:姓名,年龄，薪水<br>行为:吃饭,睡觉，管理</li>
</ol>
<h3 id="3-3-2-案例图解分析"><a href="#3-3-2-案例图解分析" class="headerlink" title="3.3.2 案例图解分析"></a>3.3.2 案例图解分析</h3><p>老师类，学生类，还有班主任类，实际上都是属于人类的，我们可以定义一个人类，把他们相同的属性和行为都定义在人类中，然后继承人类即可，子类特有的属性和行为就定义在子类中了。</p>
<p>如下图所示。</p>


<h3 id="3-3-3-案例代码实现"><a href="#3-3-3-案例代码实现" class="headerlink" title="3.3.3 案例代码实现"></a>3.3.3 案例代码实现</h3><p><strong>1.父类Human类</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">   <span class="comment">// 合理隐藏</span></span><br><span class="line">   <span class="keyword">private</span> String name ;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 合理暴露</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.子类Teacher类</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="comment">// 工资</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特有方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师在认真教技术！&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.子类Student类</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Human</span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.子类BanZhuren类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="comment">// 工资</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary ;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 特有方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">admin</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;班主任强调纪律问题！&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>5.测试类</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">dlei</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        dlei.setName(<span class="string">&quot;播仔&quot;</span>);</span><br><span class="line">        dlei.setAge(<span class="string">&quot;31&quot;</span>);</span><br><span class="line">        dlei.setSalary(<span class="number">1000.99</span>);</span><br><span class="line">        System.out.println(dlei.getName());</span><br><span class="line">        System.out.println(dlei.getAge());</span><br><span class="line">        System.out.println(dlei.getSalary());</span><br><span class="line">        dlei.teach();</span><br><span class="line">        </span><br><span class="line">        <span class="type">BanZhuRen</span> <span class="variable">linTao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BanZhuRen</span>();</span><br><span class="line">        linTao.setName(<span class="string">&quot;灵涛&quot;</span>);</span><br><span class="line">        linTao.setAge(<span class="string">&quot;28&quot;</span>);</span><br><span class="line">        linTao.setSalary(<span class="number">1000.99</span>);</span><br><span class="line">        System.out.println(linTao.getName());</span><br><span class="line">        System.out.println(linTao.getAge());</span><br><span class="line">        System.out.println(linTao.getSalary());</span><br><span class="line">        linTao.admin();</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">xugan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        xugan.setName(<span class="string">&quot;播仔&quot;</span>);</span><br><span class="line">        xugan.setAge(<span class="string">&quot;31&quot;</span>);</span><br><span class="line">        <span class="comment">//xugan.setSalary(1000.99); // xugan没有薪水属性，报错！</span></span><br><span class="line">        System.out.println(xugan.getName());</span><br><span class="line">        System.out.println(xugan.getAge());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-4-小结"><a href="#3-3-4-小结" class="headerlink" title="3.3.4 &#x3D;&#x3D;小结&#x3D;&#x3D;"></a>3.3.4 &#x3D;&#x3D;小结&#x3D;&#x3D;</h3><img src="/post/cd36ea51/image-20231128203159919-17012414461174.png" class="" title="image-20231128203159919"> 

<p>&#x3D;&#x3D;1.继承实际上是<strong>子类相同的属性和行为可以定义在父类中</strong>，子类<strong>特有的属性和行为由自己定义</strong>，这样就<strong>实现了相同属性和行为的重复利用</strong>，从而提高了代码复用。&#x3D;&#x3D;</p>
<p>2.子类继承父类，就可以直接得到父类的成员变量和方法。是否可以继承所有成分呢？</p>
<h2 id="3-4-子类不能继承的内容"><a href="#3-4-子类不能继承的内容" class="headerlink" title="3.4 &#x3D;&#x3D;子类不能继承的内容&#x3D;&#x3D;"></a>3.4 &#x3D;&#x3D;子类不能继承的内容&#x3D;&#x3D;</h2><img src="/post/cd36ea51/image-20231128203101666-17012414461175.png" class="" title="image-20231128203101666">

<img src="java1-0/image-20231128203218031-17012414461186.png" alt="image-20231128203218031" style="zoom:50%;" />  

<blockquote>
<p>子类不能继承的内容：</p>
<ol>
<li><p><strong>私有成员方法：</strong> 私有成员变量继承了，只不过不可以直接的方法访问，可以通过公共的get方法去访问.,但是私有的成员方法真的访问不了。</p>
<img src="/post/cd36ea51/image-20231128203431800-170124144611810.png" class="" title="image-20231128203431800">  

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> privateVariable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 私有方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 子类不能继承 privateVariable 和 privateMethod</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>构造方法：</strong> 构造方法不能被继承。子类会调用父类的构造方法，但是子类无法直接继承父类的构造方法。子类可以通过使用 <code>super()</code> 调用父类的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 父类的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 子类不能继承父类的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 通过super()调用父类的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>final 成员：</strong> 如果成员变量被声明为 <code>final</code>，则子类不能重写它，且它的值不能被修改。</p>
<p>如果方法被声明为 <code>final</code>，则子类不能覆盖（override）该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">finalVariable</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// final方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 子类不能重写finalVariable或finalMethod</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态成员和方法：</strong> 静态成员变量和静态方法属于类而不是实例，因此它们不会被继承。</p>
<p>子类可以直接访问父类的静态成员和方法，但是无法继承。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVariable</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 子类不能继承staticVariable或staticMethod</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h3 id="3-4-1-引入"><a href="#3-4-1-引入" class="headerlink" title="3.4.1 引入"></a>3.4.1 引入</h3><blockquote>
<p>并不是父类的所有内容都可以给子类继承的：</p>
<p><strong>子类不能继承父类的构造方法。</strong></p>
<p>&#x3D;&#x3D;<strong>值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter&#x2F;setter方法访问父类的private成员变量。</strong>&#x3D;&#x3D;</p>
</blockquote>
<h3 id="3-4-1-演示代码"><a href="#3-4-1-演示代码" class="headerlink" title="3.4.1 演示代码"></a>3.4.1 演示代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        System.out.println(z.num1);</span><br><span class="line"><span class="comment">//		System.out.println(z.num2); // 私有的子类无法使用</span></span><br><span class="line">        <span class="comment">// 通过getter/setter方法访问父类的private成员变量</span></span><br><span class="line">        System.out.println(z.getNum2());</span><br><span class="line"></span><br><span class="line">        z.show1();</span><br><span class="line">        <span class="comment">// z.show2(); // 私有的子类无法使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum2</span><span class="params">(<span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num2 = num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="虚方法表"><a href="#虚方法表" class="headerlink" title="&#x3D;&#x3D;虚方法表&#x3D;&#x3D;"></a>&#x3D;&#x3D;虚方法表&#x3D;&#x3D;</h2><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><img src="/post/cd36ea51/image-20231128203535526-17012414461187.png" class="" title="image-20231128203535526">

<p> a类成员想调用p类的方法P</p>
<p>一级一级往上找？拜托，太逊了，真的很耗费时间</p>
<ol>
<li>从最顶级(n)的父类那里设立了一个&#x3D;&#x3D;虚方法表&#x3D;&#x3D;</li>
<li>这个虚方法表里面放了&#x3D;&#x3D;经常要用到的非private,非final,非static的方法&#x3D;&#x3D;</li>
<li>下一级(n-1)会继承顶级的&#x3D;&#x3D;虚方法表&#x3D;&#x3D;并且把自己常用的方法也放入并且融合为一个心的proplus虚方法表</li>
<li>以此类推循环，直到A类的成员就可以从虚方法表里面找到P类的方法P，虚方法！如果不是虚方法还要一层一层找</li>
</ol>
<img src="/post/cd36ea51/image-20231128203554245-17012414461188.png" class="" title="image-20231128203554245">





<h3 id="内存图分析"><a href="#内存图分析" class="headerlink" title="内存图分析"></a>内存图分析</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="/post/cd36ea51/image-20231128203659819-17012414461189.png" class="" title="image-20231128203659819"></h3><h2 id="继承中成员的访问特点"><a href="#继承中成员的访问特点" class="headerlink" title="继承中成员的访问特点"></a>继承中成员的访问特点</h2><img src="/post/cd36ea51/image-20231128203726825-170124144611827.png" class="" title="image-20231128203726825"> 

<h3 id="super使用场景"><a href="#super使用场景" class="headerlink" title="super使用场景"></a>super使用场景</h3><blockquote>
<p><code>super</code> 关键字主要用于在子类中引用父类的成员，但它的使用场景并不仅限于子类的方法中。主要的使用场景包括：</p>
<ol>
<li><p><strong>在子类的方法中使用：</strong> 这是 <code>super</code> 最常见的用法。在子类的方法中，可以使用 <code>super</code> 关键字来调用父类的成员变量和方法，解决命名冲突或者直接访问父类的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent class method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child class method&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Child class number: &quot;</span> + number);</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent class number: &quot;</span> + <span class="built_in">super</span>.number); <span class="comment">// 使用 super 调用父类的成员变量</span></span><br><span class="line">        <span class="built_in">super</span>.display(); <span class="comment">// 使用 super 调用父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在子类的构造方法中使用：</strong> 在子类的构造方法中，可以使用 <code>super</code> 关键字来调用父类的构造方法。这样&#x3D;&#x3D;可以<strong>确保在创建子类对象时，先执行父类的构造方法，然后再执行子类的构造方法</strong>。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent class constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Child class constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在内部类中使用：</strong> 如果在子类中定义了内部类，并且内部类中存在与外部类相同名称的成员，可以使用 <code>super</code> 关键字来引用外部类的成员。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner class x: &quot;</span> + x); <span class="comment">// 访问内部类的 x</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Outer class x: &quot;</span> + Outer.<span class="built_in">this</span>.x); <span class="comment">// 使用 super 关键字访问外部类的 x</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<img src="/post/cd36ea51/image-20231128203811005-170124144611811.png" class="" title="image-20231128203811005">

<h2 id="3-5-继承后的特点—成员变量"><a href="#3-5-继承后的特点—成员变量" class="headerlink" title="3.5 继承后的特点—成员变量"></a>3.5 继承后的特点—成员变量</h2><p>当类之间产生了继承关系后，其中各类中的成员变量，又产生了哪些影响呢？</p>
<h3 id="3-5-1-成员变量不重名"><a href="#3-5-1-成员变量不重名" class="headerlink" title="3.5.1 成员变量不重名"></a>3.5.1 成员变量不重名</h3><p>如果子类父类中出现<strong>不重名</strong>的成员变量，这时的访问是<strong>没有影响的</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	<span class="comment">// Fu中的成员变量</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	<span class="comment">// Zi中的成员变量</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// Zi中的成员方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 访问父类中的num</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Fu num=&quot;</span>+num); <span class="comment">// 继承而来，所以直接访问。</span></span><br><span class="line">		<span class="comment">// 访问子类中的num2</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Zi num2=&quot;</span>+num2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">		<span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>(); </span><br><span class="line">      	<span class="comment">// 调用子类中的show方法</span></span><br><span class="line">		z.show();  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">演示结果：</span><br><span class="line"><span class="type">Fu</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="type">Zi</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-2-成员变量重名"><a href="#3-5-2-成员变量重名" class="headerlink" title="3.5.2 成员变量重名"></a>3.5.2 成员变量重名</h3><p>如果子类父类中出现<strong>重名</strong>的成员变量，这时的访问是<strong>有影响的</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu1</span> &#123;</span><br><span class="line">	<span class="comment">// Fu中的成员变量。</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi1</span> <span class="keyword">extends</span> <span class="title class_">Fu1</span> &#123;</span><br><span class="line">	<span class="comment">// Zi中的成员变量</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 访问父类中的num</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Fu num=&quot;</span> + num);</span><br><span class="line">		<span class="comment">// 访问子类中的num</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Zi num=&quot;</span> + num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// 创建子类对象</span></span><br><span class="line">		<span class="type">Zi1</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi1</span>(); </span><br><span class="line">      	<span class="comment">// 调用子类中的show方法</span></span><br><span class="line">		z1.show(); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">演示结果：</span><br><span class="line"><span class="type">Fu</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">6</span></span><br><span class="line"><span class="type">Zi</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>子父类中出现了同名的成员变量时，子类会优先访问自己对象中的成员变量。如果此时想访问父类成员变量如何解决呢？我们可以使用super关键字。</p>
<h3 id="3-5-3-super访问父类成员变量"><a href="#3-5-3-super访问父类成员变量" class="headerlink" title="3.5.3  super访问父类成员变量"></a>3.5.3  super访问父类成员变量</h3><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用<code>super</code> 关键字，修饰父类成员变量，类似于之前学过的 <code>this</code> 。</p>
<p>&#x3D;&#x3D;需要注意的是：<strong>super代表的是父类对象的引用，this代表的是当前对象的引用。</strong>&#x3D;&#x3D;</p>
<p><strong>使用格式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>.父类成员变量名/方法</span><br></pre></td></tr></table></figure>

<p>子类方法需要修改，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	<span class="comment">// Fu中的成员变量。</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	<span class="comment">// Zi中的成员变量</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 访问方法中的num</span></span><br><span class="line">        System.out.println(<span class="string">&quot;method num=&quot;</span> + num);</span><br><span class="line">        <span class="comment">// 访问子类中的num</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Zi num=&quot;</span> + <span class="built_in">this</span>.num);</span><br><span class="line">        <span class="comment">// 访问父类中的num</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Fu num=&quot;</span> + <span class="built_in">super</span>.num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// 创建子类对象</span></span><br><span class="line">		<span class="type">Zi1</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi1</span>(); </span><br><span class="line">      	<span class="comment">// 调用子类中的show方法</span></span><br><span class="line">		z1.show(); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">演示结果：</span><br><span class="line">method num=<span class="number">1</span></span><br><span class="line">Zi num=<span class="number">6</span></span><br><span class="line">Fu num=<span class="number">5</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：Fu 类中的成员变量是非私有的，子类中可以直接访问。</p>
<p>若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。</p>
</blockquote>
<h2 id="3-6-继承后的特点—成员方法"><a href="#3-6-继承后的特点—成员方法" class="headerlink" title="3.6 继承后的特点—成员方法"></a>3.6 继承后的特点—成员方法</h2><p>当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？</p>
<h3 id="3-6-1-成员方法不重名"><a href="#3-6-1-成员方法不重名" class="headerlink" title="3.6.1 成员方法不重名"></a>3.6.1 成员方法不重名</h3><p>如果子类父类中出现<strong>不重名</strong>的成员方法，这时的调用是<strong>没有影响的</strong>。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Fu类中的show方法执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Zi类中的show2方法执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">     	<span class="comment">//子类中没有show方法，但是可以找到父类方法去执行</span></span><br><span class="line">		z.show(); </span><br><span class="line">		z.show2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-2-成员方法重名"><a href="#3-6-2-成员方法重名" class="headerlink" title="3.6.2 成员方法重名"></a>3.6.2 成员方法重名</h3><p>如果子类父类中出现<strong>重名</strong>的成员方法，则创建子类对象调用该方法的时候，&#x3D;&#x3D;子类对象会优先调用自己的方法。&#x3D;&#x3D;</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Fu show&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	<span class="comment">//子类重写了父类的show方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Zi show&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo05</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">     	<span class="comment">// 子类中有show方法，只执行重写后的show方法</span></span><br><span class="line">		z.show();  <span class="comment">// Zi show</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-方法重写"><a href="#3-7-方法重写" class="headerlink" title="3.7 方法重写"></a>3.7 方法重写</h2><h3 id="3-7-1-概念"><a href="#3-7-1-概念" class="headerlink" title="3.7.1 概念"></a>3.7.1 概念</h3><blockquote>
<p><strong>方法重写</strong> ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。<strong>声明不变，重新实现</strong>。</p>
</blockquote>
<h3 id="3-7-2-使用场景与案例"><a href="#3-7-2-使用场景与案例" class="headerlink" title="3.7.2 使用场景与案例"></a>3.7.2 使用场景与案例</h3><blockquote>
<p>发生在子父类之间的关系。<br>子类继承了父类的方法，但是&#x3D;&#x3D;<strong>子类觉得父类的这方法不足以满足自己的需求</strong>&#x3D;&#x3D;，子类重新写了一个与父类同名的方法，以便覆盖父类的该方 法。</p>
</blockquote>
<p>例如：我们定义了一个动物类代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物跑的很快！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物都可以叫~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义一个猫类，猫可能认为父类cry()方法不能满足自己的需求</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们一起学猫叫，喵喵喵！喵的非常好听！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// 创建子类对象</span></span><br><span class="line">      	<span class="type">Cat</span> <span class="variable">ddm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>()；</span><br><span class="line">        <span class="comment">// 调用父类继承而来的方法</span></span><br><span class="line">        ddm.run();</span><br><span class="line">      	<span class="comment">// 调用子类重写的方法</span></span><br><span class="line">      	ddm.cry();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-2-Override重写注解"><a href="#3-7-2-Override重写注解" class="headerlink" title="3.7.2 @Override重写注解"></a>3.7.2 @Override重写注解</h3><blockquote>
<ul>
<li><p>@Override:注解，重写注解校验！</p>
</li>
<li><p>&#x3D;&#x3D;这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错&#x3D;&#x3D;。</p>
</li>
<li><p>建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错！</p>
</li>
</ul>
</blockquote>
<p>加上后的子类代码形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">     <span class="comment">// 声明不变，重新实现</span></span><br><span class="line">    <span class="comment">// 方法名称与父类全部一样，只是方法体中的功能重写写了！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们一起学猫叫，喵喵喵！喵的非常好听！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-7-3-注意事项"><a href="#3-7-3-注意事项" class="headerlink" title="3.7.3 &#x3D;&#x3D;注意事项&#x3D;&#x3D;"></a>3.7.3 &#x3D;&#x3D;注意事项&#x3D;&#x3D;</h3><ol>
<li>&#x3D;&#x3D;方法重写是发生在子父类之间的关系。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;子类方法覆盖父类方法，**<a href="#%E6%9D%83%E9%99%90">必须要保证权限大于等于父类权限</a>**。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。&#x3D;&#x3D;</li>
</ol>
<h2 id="3-8-继承后的特点—构造方法"><a href="#3-8-继承后的特点—构造方法" class="headerlink" title="3.8 继承后的特点—构造方法"></a>3.8 继承后的特点—构造方法</h2><h3 id="3-8-1-引入"><a href="#3-8-1-引入" class="headerlink" title="3.8.1 引入"></a>3.8.1 引入</h3><p>当类之间产生了关系，其中各类中的构造方法，又产生了哪些影响呢？<br>首先我们要回忆两个事情，构造方法的定义格式和作用。</p>
<ol>
<li><p>&#x3D;&#x3D;<strong>构造方法的名字是与类名一致的。</strong>所以子类是无法继承父类构造方法的。&#x3D;&#x3D;</p>
</li>
<li><blockquote>
<p><strong>构造方法的作用是初始化对象成员变量数据的</strong>。</p>
<p>所以子类的初始化过程中，必须先执行父类的初始化动作。</p>
<p>子类的构造方法中默认有一个<code>super()</code> ，表示调用父类的构造方法</p>
<p>父类成员变量初始化后，才可以给子类使用。（<strong>先有爸爸，才能有儿子</strong>）</p>
</blockquote>
</li>
</ol>
<hr>
<p>&#x3D;&#x3D;<strong>继承后子类构方法器特点:子类所有构造方法的第一行都会默认先调用<em>父类的无参构造方法</em></strong>&#x3D;&#x3D;**</p>
<hr>
<h3 id="3-8-2-案例"><a href="#3-8-2-案例" class="headerlink" title="3.8.2 案例"></a>3.8.2 案例</h3><p>按如下需求定义类:</p>
<ol>
<li>人类<br>成员变量: 姓名,年龄<br>成员方法: 吃饭</li>
<li>学生类<br>成员变量: 姓名,年龄,成绩<br>成员方法: 吃饭</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类无参&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter/setter省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//super(); // 调用父类无参,默认就存在，可以不写，必须再第一行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类无参&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="comment">//super();  // 调用父类无参,默认就存在，可以不写，必须再第一行</span></span><br><span class="line">        <span class="built_in">this</span>.score = score;    </span><br><span class="line">        System.out.println(<span class="string">&quot;子类有参&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">99.9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">父类无参</span><br><span class="line">子类无参</span><br><span class="line">----------</span><br><span class="line">父类无参</span><br><span class="line">子类有参</span><br></pre></td></tr></table></figure>

<h3 id="3-8-3-小结"><a href="#3-8-3-小结" class="headerlink" title="3.8.3 小结"></a>3.8.3 小结</h3><ul>
<li>&#x3D;&#x3D;子类构造方法执行的时候，都会在第一行默认先调用父类无参数构造方法一次。&#x3D;&#x3D;</li>
<li>子类构造方法的第一行都隐含了一个**super()<strong>去调用父类无参数构造方法，</strong>super()**可以省略不写。</li>
</ul>
<h2 id="3-9-super-…-和this-…"><a href="#3-9-super-…-和this-…" class="headerlink" title="3.9 super(…)和this(…)"></a>3.9 super(…)和this(…)</h2><h3 id="3-9-1-引入"><a href="#3-9-1-引入" class="headerlink" title="3.9.1  引入"></a>3.9.1  引入</h3><p>请看上节中的如下案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类无参&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter/setter省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//super(); // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类无参&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="comment">//super();  // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行</span></span><br><span class="line">        <span class="built_in">this</span>.score = score;    </span><br><span class="line">        System.out.println(<span class="string">&quot;子类有参&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="comment">// getter/setter省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用子类有参数构造方法</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">99.9</span>);</span><br><span class="line">        System.out.println(s2.getScore()); <span class="comment">// 99.9</span></span><br><span class="line">        System.out.println(s2.getName()); <span class="comment">// 输出 null</span></span><br><span class="line">        System.out.println(s2.getAge()); <span class="comment">// 输出 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>发现，<strong>子类有参数构造方法只是初始化了自己对象中的成员变量score</strong></p>
<p>而父类中的成员变量name和age依然是没有数据的，怎么解决这个问题呢?</p>
<p>&#x3D;&#x3D;借助与super(…)去调用父类构造方法，以便初始化继承自父类对象的name和age.&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name ， <span class="type">int</span> age，<span class="type">double</span> score)</span> &#123;</span><br><span class="line">   <span class="built_in">super</span>(name ,age);<span class="comment">// 调用父类有参构造方法Person(String name , int age)初始化name和age</span></span><br><span class="line">   <span class="built_in">this</span>.score = score;    </span><br><span class="line">   System.out.println(<span class="string">&quot;子类有参&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样才能完美的初始化子类的所有成员变量，包括从父亲那里继承的</p>
</blockquote>
<h3 id="3-9-2-super和this的用法格式"><a href="#3-9-2-super和this的用法格式" class="headerlink" title="3.9.2 super和this的用法格式"></a>3.9.2 super和this的用法格式</h3><p>super和this完整的用法如下，其中this，super访问成员我们已经接触过了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.成员变量    	--    本类的</span><br><span class="line"><span class="built_in">super</span>.成员变量    	--    父类的</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.成员方法名()  	--    本类的    </span><br><span class="line"><span class="built_in">super</span>.成员方法名()   --    父类的</span><br></pre></td></tr></table></figure>

<p>接下来我们使用调用构造方法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>(...) -- 调用父类的构造方法，根据参数匹配确认</span><br><span class="line"><span class="built_in">this</span>(...) -- 调用本类的其他构造方法，根据参数匹配确认</span><br></pre></td></tr></table></figure>

<h3 id="3-9-3-super-…-用法演示"><a href="#3-9-3-super-…-用法演示" class="headerlink" title="3.9.3 super(….)用法演示"></a>3.9.3 super(….)用法演示</h3><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;凤姐&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类无参&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name , <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">        <span class="built_in">this</span>.age = age ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter/setter省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//super(); // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类无参&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name ， <span class="type">int</span> age，<span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name ,age);<span class="comment">// 调用父类有参构造方法Person(String name , int age)初始化name和age</span></span><br><span class="line">        <span class="built_in">this</span>.score = score;    </span><br><span class="line">        System.out.println(<span class="string">&quot;子类有参&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="comment">// getter/setter省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用子类有参数构造方法</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>，<span class="number">20</span>，<span class="number">99</span>);</span><br><span class="line">        System.out.println(s2.getScore()); <span class="comment">// 99</span></span><br><span class="line">        System.out.println(s2.getName()); <span class="comment">// 输出 张三</span></span><br><span class="line">        System.out.println(s2.getAge()); <span class="comment">// 输出 20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。&#x3D;&#x3D;手动调用父类构造会覆盖默认的super()。&#x3D;&#x3D;</strong></p>
<p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p>
<p>super(..)是根据参数去确定调用父类哪个构造方法的。</p>
<h3 id="3-9-4-super-…-案例图解"><a href="#3-9-4-super-…-案例图解" class="headerlink" title="3.9.4 super(…)案例图解"></a>3.9.4 super(…)案例图解</h3><p><strong>父类空间优先于子类对象产生</strong></p>
<p>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造七调用时，一定先调用父类的构造方法。理解图解如下：</p>
<img src="/post/cd36ea51/2-170124144611813.jpg" class="">



<h3 id="3-9-5-this-…-用法演示"><a href="#3-9-5-this-…-用法演示" class="headerlink" title="3.9.5 this(…)用法演示"></a>3.9.5 this(…)用法演示</h3><p>this(…)</p>
<ul>
<li>&#x3D;&#x3D;默认是去找本类中的其他构造方法&#x3D;&#x3D;，根据参数来确定具体调用哪一个构造方法。</li>
<li>为了借用其他构造方法的功能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima._08this和<span class="built_in">super</span>调用构造方法;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * this(...):</span></span><br><span class="line"><span class="comment"> *    默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。</span></span><br><span class="line"><span class="comment"> *    为了借用其他构造方法的功能。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">xuGan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(xuGan.getName()); <span class="comment">// 输出:徐干</span></span><br><span class="line">        System.out.println(xuGan.getAge());<span class="comment">// 输出:21</span></span><br><span class="line">        System.out.println(xuGan.getSex());<span class="comment">// 输出： 男</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 很弱，我的兄弟很牛逼啊，我可以调用其他构造方法：Student(String name, int age, char sex)</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;徐干&quot;</span>,<span class="number">21</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">        <span class="built_in">this</span>.age = age   ;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex   ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-9-6-小结"><a href="#3-9-6-小结" class="headerlink" title="3.9.6 小结"></a>3.9.6 小结</h3><ul>
<li><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></li>
<li><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></li>
<li><strong>super(..)和this(…)是根据参数去确定调用父类哪个构造方法的。</strong></li>
<li>super(..)可以调用父类构造方法初始化继承自父类的成员变量的数据。</li>
<li>this(..)可以调用本类中的其他构造方法。</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;父类的无参构造&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;Parent class parameterized constructor with value: &quot;</span> + value);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">     Child c=<span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">     Child c1=<span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>(); <span class="comment">// 默认调用父类的无参构造方法</span></span><br><span class="line">     System.out.println(<span class="string">&quot;子类的无参构造&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>(); <span class="comment">// 调用本类的无参构造方法，间接调用了父类的无参构造方法</span></span><br><span class="line">     System.out.println(<span class="string">&quot;子类的value: &quot;</span> + value);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//父类的无参构造</span></span><br><span class="line"><span class="comment">//子类的无参构造</span></span><br><span class="line"><span class="comment">//-----------</span></span><br><span class="line"><span class="comment">//父类的无参构造</span></span><br><span class="line"><span class="comment">//子类的无参构造</span></span><br><span class="line"><span class="comment">//子类的value: 1</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="3-10-继承的特点"><a href="#3-10-继承的特点" class="headerlink" title="3.10 继承的特点"></a>3.10 继承的特点</h2><ol>
<li>Java只支持单继承，不支持多继承。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个类只能有一个父类，不可以有多个父类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125; <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// class C2 extends A, B &#123;&#125; // error</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>一个类可以有多个子类。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A可以有多个子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span> <span class="keyword">extends</span>  <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>可以多层继承。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C1</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>顶层父类是Object类。所有的类默认继承Object，作为父类。</p>
</blockquote>
<h2 id="测试案例："><a href="#测试案例：" class="headerlink" title="测试案例："></a>测试案例：</h2><p>会写一个继承结构下的标准Javabean即可</p>
<p>需求：</p>
<p>​	猫：属性，姓名，年龄，颜色</p>
<p>​	狗：属性，姓名，年龄，颜色，吼叫</p>
<p> 分享书写技巧：</p>
<p>​        1.在大脑中要区分谁是父，谁是子</p>
<p>​        2.把共性写到父类中，独有的东西写在子类中</p>
<p>​        3.开始编写标准Javabean（从上往下写）</p>
<p>​        4.在测试类中，创建对象并赋值调用</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">//姓名，年龄，颜色</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="comment">//因为猫类中没有独有的属性。</span></span><br><span class="line">    <span class="comment">//所以此时不需要写私有的成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//空参</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要带子类和父类中所有的属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name,age,color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="comment">//Dog ：吼叫</span></span><br><span class="line">    <span class="keyword">private</span> String wang;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带参构造：带子类加父类所有的属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age, String color,String wang)</span> &#123;</span><br><span class="line">        <span class="comment">//共性的属性交给父类赋值</span></span><br><span class="line">        <span class="built_in">super</span>(name,age,color);</span><br><span class="line">        <span class="comment">//独有的属性自己赋值</span></span><br><span class="line">        <span class="built_in">this</span>.wang = wang;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getWang</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> wang;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWang</span><span class="params">(String wang)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wang = wang;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Animal ： 姓名，年龄，颜色</span></span><br><span class="line">        <span class="comment">//Cat :</span></span><br><span class="line">        <span class="comment">//Dog ：吼叫</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建狗的对象</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺财&quot;</span>,<span class="number">2</span>,<span class="string">&quot;黑色&quot;</span>,<span class="string">&quot;嗷呜~~&quot;</span>);</span><br><span class="line">        System.out.println(d.getName()+<span class="string">&quot;, &quot;</span> + d.getAge() + <span class="string">&quot;, &quot;</span> + d.getColor() + <span class="string">&quot;, &quot;</span> + d.getWang());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建猫的对象</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;中华田园猫&quot;</span>,<span class="number">3</span>,<span class="string">&quot;黄色&quot;</span>);</span><br><span class="line">        System.out.println(c.getName() + <span class="string">&quot;, &quot;</span> + c.getAge() + <span class="string">&quot;, &quot;</span> + c.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="多态包final★★"><a href="#多态包final★★" class="headerlink" title="&#x3D;&#x3D;多态包final★★&#x3D;&#x3D;"></a>&#x3D;&#x3D;多态包final★★&#x3D;&#x3D;</h1><ul>
<li><p><input disabled="" type="checkbox"> 
能够说出使用多态的前提条件</p>
</li>
<li><p><input disabled="" type="checkbox"> 
理解多态的向上转型</p>
</li>
<li><p><input disabled="" type="checkbox"> 
理解多态的向下转型</p>
</li>
<li><p><input disabled="" type="checkbox"> 
能够知道多态的使用场景</p>
</li>
<li><p><input disabled="" type="checkbox"> 
包的作用</p>
</li>
<li><p><input disabled="" type="checkbox"> 
public和private权限修饰符的作用</p>
</li>
<li><p><input disabled="" type="checkbox"> 
描述final修饰的类的特点</p>
</li>
<li><p><input disabled="" type="checkbox"> 
描述final修饰的方法的特点</p>
</li>
<li><p><input disabled="" type="checkbox"> 
描述final修饰的变量的特点</p>
</li>
</ul>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="最简单的用法"><a href="#最简单的用法" class="headerlink" title="最简单的用法"></a>最简单的用法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soft1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.AnnotationMirror;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        test(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line">        Animal a=<span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        System.out.println(a.name);</span><br><span class="line"><span class="comment">//        a.Eat();</span></span><br><span class="line">        <span class="comment">//编译的时候会看左边是否有这个成员方法，没有就报错，也就是现在是子类特有的时候</span></span><br><span class="line"></span><br><span class="line">        Dog b=(Dog)a;</span><br><span class="line">        b.Eat();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Animal a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        a.Say();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name=<span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Say</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>  <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    String name=<span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Say</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪汪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">Eat</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃东西！Q&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    String name=<span class="string">&quot;猫&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Say</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵喵&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-1-多态的形式"><a href="#1-1-多态的形式" class="headerlink" title="1.1 多态的形式"></a>1.1 多态的形式</h2><img src="/post/cd36ea51/image-20231124204452286-170124144611812.png" class="" title="image-20231124204452286"> 

<blockquote>
<p>可以以一种&#x3D;&#x3D;<strong>通用的方式操作对象</strong>&#x3D;&#x3D;，而&#x3D;&#x3D;不需要关心对象的具体类型：&#x3D;&#x3D;</p>
<ol>
<li><p><strong>多态的概念</strong>：多态是指&#x3D;&#x3D;<strong>同样的方法调用可以在不同的对象上产生不同的行为</strong>&#x3D;&#x3D;。在Java中，多态性通过&#x3D;&#x3D;方法的重写&#x3D;&#x3D;和&#x3D;&#x3D;方法的重载&#x3D;&#x3D;来实现。</p>
</li>
<li><p><strong>继承与多态</strong>：&#x3D;&#x3D;多态是建立在继承关系之上&#x3D;&#x3D;。子类可以&#x3D;&#x3D;覆盖（重写）&#x3D;&#x3D;从父类继承而来的方法，当通过父类引用调用这些被子类重写的方法时，&#x3D;&#x3D;<strong>根据实际的子类类型会执行相应的重写方法。</strong>&#x3D;&#x3D;</p>
</li>
<li><p><strong>方法重写（Override）</strong>：子类可以提供一个&#x3D;&#x3D;<strong>与父类方法签名相同的方法</strong>&#x3D;&#x3D;，并且可以&#x3D;&#x3D;重新定义该方法的行为&#x3D;&#x3D;。当使用父类的引用调用被子类重写的方法时，将根据实际的对象类型执行相应的重写方法。</p>
</li>
<li><p><strong>动态绑定</strong>：Java中的多态是通过动态绑定实现的，也称为&#x3D;&#x3D;运行时多态&#x3D;&#x3D;。这意味着方法调用的具体实现是在运行时确定的，而不是在编译时确定的。</p>
</li>
<li><p><strong>抽象类和接口</strong>：抽象类和接口是实现多态的重要方式。&#x3D;&#x3D;<strong>抽象类和接口定义了规范</strong>&#x3D;&#x3D;，子类可以根据需要去实现这些规范，并且可以&#x3D;&#x3D;<strong>通过父类或接口类型引用子类对象</strong>&#x3D;&#x3D;，实现统一的对外接口。</p>
</li>
<li><p><strong>向上转型</strong>：可以使用&#x3D;&#x3D;父类类型的引用指向子类对象&#x3D;&#x3D;，这被称为向上转型。通过向上转型，可以在不关心具体子类类型的情况下，统一地对待各个子类对象，实现多态。</p>
</li>
</ol>
</blockquote>
<p><strong>多态是继封装、继承之后，面向对象的第三大特性。</strong></p>
<p><strong>多态是出现在继承或者实现关系中的</strong>。</p>
<p><strong>多态体现的格式</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类/实现类构造器;</span><br><span class="line">变量名.方法名();</span><br></pre></td></tr></table></figure>

<p><strong>多态的前提</strong>：有继承关系，子类对象是可以赋值给父类类型的变量。例如Animal是一个动物类型，而Cat是一个猫类型。Cat继承了Animal，Cat对象也是Animal类型，自然可以赋值给父类类型的变量。</p>
<h2 id="1-2-多态的使用场景"><a href="#1-2-多态的使用场景" class="headerlink" title="1.2 多态的使用场景"></a>1.2 多态的使用场景</h2><p>如果没有多态，在下图中register方法只能传递学生对象，其他的Teacher和administrator对象是无法传递给register方法方法的，在这种情况下，只能定义三个不同的register方法分别接收学生，老师和管理员。</p>


<p>有了多态之后，方法的形参就可以定义为共同的父类Person。</p>
<p><strong>要注意的是：</strong></p>
<ul>
<li>&#x3D;&#x3D;当一个方法的形参是一个类，我们可以传递<strong>这个类所有的子类对象。</strong>&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;当一个方法的形参是一个接口，我们可以传递这个接口<strong>所有的实现类对象</strong>（后面会学）。&#x3D;&#x3D;</li>
<li>而且多态还可以&#x3D;&#x3D;根据传递的不同对象来调用不同类中的方法。&#x3D;&#x3D;</li>
</ul>


<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    空参构造</span><br><span class="line">    带全部参数的构造</span><br><span class="line">    get和set方法</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;, &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">子类<span class="number">1</span>：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Administrator</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;管理员的信息为：&quot;</span> + getName() + <span class="string">&quot;, &quot;</span> + getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">子类<span class="number">2</span>：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生的信息为：&quot;</span> + getName() + <span class="string">&quot;, &quot;</span> + getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">子类<span class="number">3</span>：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师的信息为：&quot;</span> + getName() + <span class="string">&quot;, &quot;</span> + getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">测试类：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建三个对象，并调用register方法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        s.setAge(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        t.setName(<span class="string">&quot;王建国&quot;</span>);</span><br><span class="line">        t.setAge(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Administrator</span> <span class="variable">admin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Administrator</span>();</span><br><span class="line">        admin.setName(<span class="string">&quot;管理员&quot;</span>);</span><br><span class="line">        admin.setAge(<span class="number">35</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        register(s);</span><br><span class="line">        register(t);</span><br><span class="line">        register(admin);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法既能接收老师，又能接收学生，还能接收管理员</span></span><br><span class="line">    <span class="comment">//只能把参数写成这三个类型的父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Person p)</span>&#123;</span><br><span class="line">        p.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-3-多态的定义和前提"><a href="#1-3-多态的定义和前提" class="headerlink" title="1.3 多态的定义和前提"></a>1.3 多态的定义和前提</h2><p><strong>多态</strong>： &#x3D;&#x3D;是指同一行为，具有多个不同表现形式。&#x3D;&#x3D;</p>
<p>从上面案例可以看出，Cat和Dog都是动物，都是吃这一行为，但是出现的效果（表现形式）是不一样的。</p>
<p> <strong>前提【重点】</strong></p>
<ol>
<li><p>有继承或者实现关系</p>
</li>
<li><p>&#x3D;&#x3D;方法的重写【意义体现：不重写，无意义】&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;父类引用指向子类对象【格式体现】&#x3D;&#x3D;</p>
<blockquote>
<p>父类类型：指子类对象继承的&#x3D;&#x3D;父类类型&#x3D;&#x3D;，或者实现的&#x3D;&#x3D;父接口类型。&#x3D;&#x3D;</p>
</blockquote>
</li>
</ol>
<h2 id="1-4-多态的运行特点"><a href="#1-4-多态的运行特点" class="headerlink" title="1.4 多态的运行特点"></a>1.4 多态的运行特点</h2><img src="/post/cd36ea51/image-20231124205912921-170124144611816.png" class="" title="image-20231124205912921">

<blockquote>
<p><strong>调用成员变量时：编译看左边，运行看左边</strong></p>
<p>调用成员方法时：编译看左边，&#x3D;&#x3D;运行看右边&#x3D;&#x3D;</p>
</blockquote>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Fu</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>()；</span><br><span class="line"><span class="comment">//编译看左边的父类中有没有name这个属性，没有就报错</span></span><br><span class="line"><span class="comment">//在实际运行的时候，把父类name属性的值打印出来</span></span><br><span class="line">System.out.println(f.name);</span><br><span class="line"><span class="comment">//编译看左边的父类中有没有show这个方法，没有就报错</span></span><br><span class="line"><span class="comment">//在实际运行的时候，运行的是子类中的show方法</span></span><br><span class="line">f.show();</span><br></pre></td></tr></table></figure>



<h2 id="多态的内存解释"><a href="#多态的内存解释" class="headerlink" title="多态的内存解释"></a>多态的内存解释</h2><img src="/post/cd36ea51/image-20231124213633072-170124144611817.png" class="" title="image-20231124213633072"> 



<h2 id="1-5-多态的弊端"><a href="#1-5-多态的弊端" class="headerlink" title="1.5 多态的弊端"></a>1.5 多态的弊端</h2><img src="/post/cd36ea51/image-20231124215826563-170124144611818.png" class="" title="image-20231124215826563"> 

<p>我们已经知道多态&#x3D;&#x3D;编译阶段是看左边父类类型的&#x3D;&#x3D;，如果子类有些独有的功能，此时<strong>多态的写法就无法访问子类独有功能了</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>｛</span><br><span class="line">        System.out.println(<span class="string">&quot;动物吃东西！&quot;</span>)</span><br><span class="line">    ｝</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃骨头&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        a.eat();</span><br><span class="line">        a.catchMouse();<span class="comment">//编译报错，编译看左边，Animal没有这个方法</span></span><br><span class="line">        <span class="comment">//直接报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;子类转换为父类，这是默认的也就是自动类型转换&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;但是父类想要转换为子类，也就是降级？那就得强制转换了。&#x3D;&#x3D;</p>
<h2 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h2><p><code>instanceof</code> 是 Java 中的一个关键字，用于检查一个对象是否是一个特定类的实例，或者是否是其子类的实例。它的语法是 <code>object instanceof Class</code>，其中 <code>object</code> 是要检查的对象，<code>Class</code> 是要检查的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal a=<span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="comment">//如果这个对象运行时是Dog类，那么就强制转换为DOg并且变量设置为b</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog b)</span><br><span class="line">&#123;</span><br><span class="line">    b.Eat();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat c) &#123;</span><br><span class="line">    c.Sleep();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;转不了，会报错&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-6-引用类型转换"><a href="#1-6-引用类型转换" class="headerlink" title="1.6 引用类型转换"></a>1.6 引用类型转换</h2><h3 id="1-6-1-为什么要转型"><a href="#1-6-1-为什么要转型" class="headerlink" title="1.6.1 为什么要转型"></a>1.6.1 为什么要转型</h3><p><strong>多态的写法就无法访问子类独有功能了。</strong></p>
<p>&#x3D;&#x3D;当使用多态方式调用方法时，首先检查父类中是否有该方法&#x3D;&#x3D;如果没有，则编译错误。</p>
<p>也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。</p>
<p>编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。</p>
<p>所以，想要调用子类特有的方法，必须做向下转型。</p>
<p>回顾基本数据类型转换</p>
<ul>
<li>自动转换: 范围小的赋值给范围大的.自动完成:double d &#x3D; 5; </li>
<li>强制转换: 范围大的赋值给范围小的,强制转换:int i &#x3D; (int)3.14</li>
</ul>
<p>​     多态的转型分为向上转型（自动转换）与向下转型（强制转换）两种。</p>
<h3 id="1-6-2-向上转型（自动转换）"><a href="#1-6-2-向上转型（自动转换）" class="headerlink" title="1.6.2 向上转型（自动转换）"></a>1.6.2 向上转型（自动转换）</h3><ul>
<li><strong>向上转型</strong>：多态本身是子类类型向父类类型向上转换（自动转换）的过程，这个过程是默认的。<br>当父类引用指向一个子类对象时，便是向上转型。<br>使用格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型  变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">如：<span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure>

<p><strong>原因是：父类类型相对与子类来说是大范围的类型，Animal是动物类，是父类类型。Cat是猫类，是子类类型。Animal类型的范围当然很大，包含一切动物。</strong>所以子类范围小可以直接自动转型给父类类型的变量。</p>
<h3 id="1-6-向下转型-（强制转换）"><a href="#1-6-向下转型-（强制转换）" class="headerlink" title="1.6&#x3D;&#x3D;向下转型&#x3D;&#x3D;（强制转换）"></a>1.6&#x3D;&#x3D;向下转型&#x3D;&#x3D;（强制转换）</h3><ul>
<li><strong>向下转型</strong>：父类类型向子类类型向下转换的过程，这个过程是强制的。<br>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</li>
</ul>
<p>使用格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子类类型 变量名 = (子类类型) 父类变量名;</span><br><span class="line">如:<span class="type">Aniaml</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">   <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span>(Cat) a;  </span><br></pre></td></tr></table></figure>

<h3 id="1-6-4-案例演示"><a href="#1-6-4-案例演示" class="headerlink" title="1.6.4 案例演示"></a>1.6.4 案例演示</h3><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。</p>
<p>转型演示，代码如下：</p>
<p>定义类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃骨头&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchHouse</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;看家&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向上转型  </span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  </span><br><span class="line">        a.eat(); 				<span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下转型  </span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;       </span><br><span class="line">        c.catchMouse(); 		<span class="comment">// 调用的是 Cat 的 catchMouse</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-5-转型的异常"><a href="#1-6-5-转型的异常" class="headerlink" title="1.6.5 转型的异常"></a>1.6.5 转型的异常</h3><p>转型的过程中，一不小心就会遇到这样的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向上转型  </span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  </span><br><span class="line">        a.eat();               <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下转型  </span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)a;       </span><br><span class="line">        d.watchHouse();        <span class="comment">// 调用的是 Dog 的 watchHouse 【运行报错】</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以通过编译，但是运行时，却报出了 <code>ClassCastException</code> ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。</p>
<h3 id="1-6-6-instanceof关键字"><a href="#1-6-6-instanceof关键字" class="headerlink" title="1.6.6 instanceof关键字"></a>1.6.6 instanceof关键字</h3><p>为了避免ClassCastException的发生，Java提供了 <code>instanceof</code> 关键字，给引用变量做类型的校验，格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">变量名 <span class="keyword">instanceof</span> 数据类型 </span><br><span class="line">如果变量属于该数据类型或者其子类类型，返回<span class="literal">true</span>。</span><br><span class="line">如果变量不属于该数据类型或者其子类类型，返回<span class="literal">false</span>。</span><br></pre></td></tr></table></figure>

<p>所以，转换前，我们最好先做一个判断，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向上转型  </span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  </span><br><span class="line">        a.eat();               <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下转型  </span></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;       </span><br><span class="line">            c.catchMouse();        <span class="comment">// 调用的是 Cat 的 catchMouse</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)a;       </span><br><span class="line">            d.watchHouse();       <span class="comment">// 调用的是 Dog 的 watchHouse</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-7-instanceof新特性"><a href="#1-6-7-instanceof新特性" class="headerlink" title="1.6.7 instanceof新特性"></a>1.6.7 instanceof新特性</h3><p>JDK14的时候提出了新特性，把判断和强转合并成了一行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新特性</span></span><br><span class="line"><span class="comment">//先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d</span></span><br><span class="line"><span class="comment">//如果不是，则不强转，结果直接是false</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog d)&#123;</span><br><span class="line">    d.lookHome();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat c)&#123;</span><br><span class="line">    c.catchMouse();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;没有这个类型，无法转换&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="1-7-综合练习"><a href="#1-7-综合练习" class="headerlink" title="1.7 综合练习"></a>1.7 综合练习</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">需求：根据需求完成代码:</span><br><span class="line">	<span class="number">1.</span>定义狗类</span><br><span class="line">		属性：</span><br><span class="line">			年龄，颜色</span><br><span class="line">		行为:</span><br><span class="line">			eat(String something)(something表示吃的东西)</span><br><span class="line">			看家lookHome方法(无参数)</span><br><span class="line"><span class="number">2.</span>定义猫类</span><br><span class="line">	属性：</span><br><span class="line">		年龄，颜色</span><br><span class="line">	行为:</span><br><span class="line">		eat(String something)方法(something表示吃的东西)</span><br><span class="line">		逮老鼠catchMouse方法(无参数)</span><br><span class="line"><span class="number">3.</span>定义Person类<span class="comment">//饲养员</span></span><br><span class="line">	属性：</span><br><span class="line">		姓名，年龄</span><br><span class="line">	行为：</span><br><span class="line">		keepPet(Dog dog,String something)方法</span><br><span class="line">			功能：喂养宠物狗，something表示喂养的东西</span><br><span class="line">	行为：</span><br><span class="line">		keepPet(Cat cat,String something)方法</span><br><span class="line">			功能：喂养宠物猫，something表示喂养的东西</span><br><span class="line">	生成空参有参构造，set和get方法  </span><br><span class="line"><span class="number">4.</span>定义测试类(完成以下打印效果):</span><br><span class="line">	keepPet(Dog dog,String somethind)方法打印内容如下：</span><br><span class="line">		年龄为<span class="number">30</span>岁的老王养了一只黑颜色的<span class="number">2</span>岁的狗</span><br><span class="line">		<span class="number">2</span>岁的黑颜色的狗两只前腿死死的抱住骨头猛吃</span><br><span class="line">	keepPet(Cat cat,String somethind)方法打印内容如下：</span><br><span class="line">		年龄为<span class="number">25</span>岁的老李养了一只灰颜色的<span class="number">3</span>岁的猫</span><br><span class="line">		<span class="number">3</span>岁的灰颜色的猫眯着眼睛侧着头吃鱼</span><br><span class="line"><span class="number">5.</span>思考：		</span><br><span class="line">	<span class="number">1.</span>Dog和Cat都是Animal的子类，以上案例中针对不同的动物，定义了不同的keepPet方法，过于繁琐，能否简化，并体会简化后的好处？</span><br><span class="line">	<span class="number">2.</span>Dog和Cat虽然都是Animal的子类，但是都有其特有方法，能否想办法在keepPet中调用特有方法？</span><br></pre></td></tr></table></figure>

<p>画图分析：</p>




<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动物类（父类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(<span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String something)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在吃&quot;</span> + something);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//猫类（子类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(<span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(age, color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String something)</span> &#123;</span><br><span class="line">        System.out.println(getAge() + <span class="string">&quot;岁的&quot;</span> + getColor() + <span class="string">&quot;颜色的猫眯着眼睛侧着头吃&quot;</span> + something);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//狗类（子类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(age, color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//行为</span></span><br><span class="line">    <span class="comment">//eat(String something)(something表示吃的东西)</span></span><br><span class="line">    <span class="comment">//看家lookHome方法(无参数)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String something)</span> &#123;</span><br><span class="line">        System.out.println(getAge() + <span class="string">&quot;岁的&quot;</span> + getColor() + <span class="string">&quot;颜色的狗两只前腿死死的抱住&quot;</span> + something + <span class="string">&quot;猛吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lookHome</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗在看家&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//饲养员类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//饲养狗</span></span><br><span class="line">   <span class="comment">/* public void keepPet(Dog dog, String something) &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;年龄为&quot; + age + &quot;岁的&quot; + name + &quot;养了一只&quot; + dog.getColor() + &quot;颜色的&quot; + dog.getAge() + &quot;岁的狗&quot;);</span></span><br><span class="line"><span class="comment">        dog.eat(something);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //饲养猫</span></span><br><span class="line"><span class="comment">    public void keepPet(Cat cat, String something) &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;年龄为&quot; + age + &quot;岁的&quot; + name + &quot;养了一只&quot; + cat.getColor() + &quot;颜色的&quot; + cat.getAge() + &quot;岁的猫&quot;);</span></span><br><span class="line"><span class="comment">        cat.eat(something);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//想要一个方法，能接收所有的动物，包括猫，包括狗</span></span><br><span class="line">    <span class="comment">//方法的形参：可以写这些类的父类 Animal</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keepPet</span><span class="params">(Animal a, String something)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog d)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄为&quot;</span> + age + <span class="string">&quot;岁的&quot;</span> + name + <span class="string">&quot;养了一只&quot;</span> + a.getColor() + <span class="string">&quot;颜色的&quot;</span> + a.getAge() + <span class="string">&quot;岁的狗&quot;</span>);</span><br><span class="line">            d.eat(something);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat c)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄为&quot;</span> + age + <span class="string">&quot;岁的&quot;</span> + name + <span class="string">&quot;养了一只&quot;</span> + c.getColor() + <span class="string">&quot;颜色的&quot;</span> + c.getAge() + <span class="string">&quot;岁的猫&quot;</span>);</span><br><span class="line">            c.eat(something);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有这种动物&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象并调用方法</span></span><br><span class="line">       <span class="comment">/* Person p1 = new Person(&quot;老王&quot;,30);</span></span><br><span class="line"><span class="comment">        Dog d = new Dog(2,&quot;黑&quot;);</span></span><br><span class="line"><span class="comment">        p1.keepPet(d,&quot;骨头&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Person p2 = new Person(&quot;老李&quot;,25);</span></span><br><span class="line"><span class="comment">        Cat c = new Cat(3,&quot;灰&quot;);</span></span><br><span class="line"><span class="comment">        p2.keepPet(c,&quot;鱼&quot;);*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建饲养员的对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;老王&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">2</span>,<span class="string">&quot;黑&quot;</span>);</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="number">3</span>,<span class="string">&quot;灰&quot;</span>);</span><br><span class="line">        p.keepPet(d,<span class="string">&quot;骨头&quot;</span>);</span><br><span class="line">        p.keepPet(c,<span class="string">&quot;鱼&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>a instanceof B</p>
<p>如果a实际是B类</p>
</blockquote>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h2 id="包的概念"><a href="#包的概念" class="headerlink" title="包的概念"></a>包的概念</h2><blockquote>
<p>包（Package）是Java中用于组织和管理类的一种机制，它有助于将类分组、避免命名冲突，并提供了一种访问控制的手段。</p>
<ol>
<li><p><strong>定义包：</strong> 在Java中，使用 <code>package</code> 关键字来定义一个包。包的定义通常放在源文件的开头，位于 <code>package</code> 关键字后面。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 类的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;这个类就属于 <code>com.example.myapp</code> 这个包。&#x3D;&#x3D;</p>
</li>
<li><p><strong>包的命名规范：</strong> &#x3D;&#x3D;包名通常使用小写字母，多个单词可以使用点（<code>.</code>）分隔&#x3D;&#x3D;。</p>
<p>按照惯例，&#x3D;&#x3D;<strong>包名是反域名</strong>（reverse domain name）的形式，确保全球唯一性&#x3D;&#x3D;。例如，<code>com.example</code> 是一个常见的包名前缀。</p>
</li>
<li><p><strong>包的导入：</strong> 在Java中，使用 <code>import</code> 语句来导入其他包中的类，以便在当前类中使用这些类。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 java.util 包中的 ArrayList 和 List 类</span></span><br><span class="line">    List&lt;String&gt; myList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类路径（Classpath）：</strong> 在运行Java程序时，&#x3D;&#x3D;<strong>Java虚拟机（JVM）需要知道在哪里找到编译后的字节码文件</strong>&#x3D;&#x3D;。类路径是一个包含类文件的目录路径或JAR文件的路径列表。包名和类路径结合，可以确保正确加载和运行类。</p>
</li>
<li><p><strong>默认包：</strong>&#x3D;&#x3D;如果一个类没有指定所属的包，它就属于默认包&#x3D;&#x3D;但是最好的做法是将每个类都放在一个明确定义的包中，以避免命名冲突和提高代码的可维护性。</p>
</li>
<li><p><strong>访问修饰符：</strong> 包也是Java中访问控制的一部分。类、变量和方法可以使用 <code>public</code>、<code>protected</code>、<code>default</code>（包级别的访问）和 <code>private</code> 这些访问修饰符来限定对它们的访问权限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> publicVar;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> protectedVar;</span><br><span class="line">    <span class="type">int</span> defaultVar; <span class="comment">// 包级别的访问权限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> privateVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h2 id="2-1-包"><a href="#2-1-包" class="headerlink" title="2.1 包"></a>2.1 包</h2><p>​	包在操作系统中其实就是一个&#x3D;&#x3D;文件夹&#x3D;&#x3D;。<strong>包是用来分门别类的管理技术，不同的技术类放在不同的包下</strong>，方便管理和维护。</p>
<p>在IDEA项目中，建包的操作如下：</p>
<img src="/post/cd36ea51/aaa-170124144611820.jpg" class="">

<p><strong>包名的命名规范</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">路径名.路径名.xxx.xxx</span><br><span class="line"><span class="comment">// 例如：com.itheima.oa</span></span><br></pre></td></tr></table></figure>

<ul>
<li>包名一般是公司域名的倒写。例如：黑马是<a target="_blank" rel="noopener" href="http://www.itheima.com,包名就可以定义成com.itheima.技术名称./">www.itheima.com,包名就可以定义成com.itheima.技术名称。</a></li>
<li>包名必须用”.“连接。</li>
<li>包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字。</li>
</ul>
<h2 id="2-2-导包"><a href="#2-2-导包" class="headerlink" title="2.2 导包"></a>2.2 导包</h2><p>什么时候需要导包？</p>
<p>​	情况一：在使用Java中提供的非核心包中的类时</p>
<p>​	情况二：使用自己写的其他包中的类时</p>
<p>什么时候不需要导包？</p>
<p>​	情况一：在使用Java核心包（java.lang）中的类时</p>
<p>​	情况二：在使用自己写的同一个包中的类时</p>
<h2 id="2-3-使用不同包下的相同类怎么办？、"><a href="#2-3-使用不同包下的相同类怎么办？、" class="headerlink" title="2.3 使用不同包下的相同类怎么办？、"></a>2.3 使用不同包下的相同类怎么办？、</h2><p>&#x3D;&#x3D;使用完整的导包&#x3D;&#x3D;</p>
<ol>
<li><p><strong>使用完整的类名：</strong> 可以使用完整的类名（包括包名）来引用相同类。这样，即使存在相同类名，由于包名不同，不会发生冲突。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 com.example.package1 包下的类</span></span><br><span class="line"><span class="keyword">package</span> com.example.package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 类的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 com.example.package2 包下的类</span></span><br><span class="line"><span class="keyword">package</span> com.example.package2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 类的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其他类中使用这两个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.package1.MyClass;</span><br><span class="line"><span class="keyword">import</span> com.example.package2.MyClass as MyClass2; <span class="comment">// 使用 as 关键字重命名，避免类名冲突</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherClass</span> &#123;</span><br><span class="line">    <span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">    com.example.package2.<span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.example</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="权限修饰符-1"><a href="#权限修饰符-1" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><h2 id="3-1-权限修饰符"><a href="#3-1-权限修饰符" class="headerlink" title="3.1 权限修饰符"></a>3.1 权限修饰符</h2><p>访问权限修饰符是按照从最大权限到最小权限的顺序排列的。下面是权限从高到低的顺序：</p>
<ol>
<li><p><strong>public：</strong></p>
<ul>
<li>公共访问级别，对所有类都是可见的。</li>
</ul>
</li>
<li><p><strong>protected：</strong></p>
<ul>
<li>受保护访问级别，对同一包内的类和所有子类可见。</li>
</ul>
</li>
<li><p><strong>默认（包级别，默认级别）：</strong></p>
<ul>
<li>如果没有指定任何访问修饰符，默认为包级别，对同一包内的类可见。</li>
</ul>
</li>
<li><p><strong>private：</strong></p>
<ul>
<li>私有访问级别，仅对同一类可见。</li>
<li><code>public &gt; protected &gt; 默认 &gt; private</code></li>
</ul>
</li>
</ol>
<ul>
<li>&#x3D;&#x3D;protect扩大了private的权限，但是又不能达到public的权利&#x3D;&#x3D;</li>
</ul>
<h2 id="3-2-不同权限的访问能力"><a href="#3-2-不同权限的访问能力" class="headerlink" title="3.2 不同权限的访问能力"></a>3.2 不同权限的访问能力</h2><table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>默认</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一类中</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>同一包中的类</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>不同包的子类</td>
<td>√</td>
<td>&#x3D;&#x3D;√&#x3D;&#x3D;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>不同包中的无关类</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>可见，public具有最大权限。private则是最小权限。</p>
<p>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p>
<ul>
<li>成员变量使用<code>private</code> ，隐藏细节。</li>
<li>构造方法使用<code> public</code> ，方便创建对象。</li>
<li>成员方法使用<code>public</code> ，方便调用方法。</li>
</ul>
<blockquote>
<p>小贴士：不加权限修饰符，就是默认权限</p>
</blockquote>
<h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>​	学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。</p>
<p>如果有一个方法我&#x3D;&#x3D;不想别人去改写里面内容，该怎么办呢？&#x3D;&#x3D;</p>
<p>Java提供了<code>final</code> 关键字，表示修饰的内容不可变。const</p>
<ul>
<li><p><strong>final</strong>：  &#x3D;&#x3D;不可改变，最终的含义。可以用于修饰类、方法和变量。&#x3D;&#x3D;</p>
<blockquote>
<ul>
<li>类：被修饰的类，不能被继承,因为一旦有后代就会不符合最终的含义了.</li>
<li>方法：被修饰的方法，不能被重写。</li>
<li>变量：被修饰的变量，有且仅能被赋值一次。不能被i修改，，</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="4-2-使用方式"><a href="#4-2-使用方式" class="headerlink" title="4.2 使用方式"></a>4.2 使用方式</h2><h3 id="4-2-1-修饰类"><a href="#4-2-1-修饰类" class="headerlink" title="4.2.1 修饰类"></a>4.2.1 修饰类</h3><p>&#x3D;&#x3D;final修饰的类，不能被继承。&#x3D;&#x3D;</p>
<blockquote>
<p>关键字”final”通常&#x3D;&#x3D;放在修饰符（如public、private等）之后&#x3D;&#x3D;，用于声明一个不可继承的类、不可修改的方法或不可变的变量。</p>
<p>都行啊</p>
</blockquote>
<p>格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> class 类名 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;<span class="comment">//直接红下划线</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// class Zi extends Fu &#123;&#125; // 报错,不能继承final的类</span></span><br></pre></td></tr></table></figure>

<p>查询API发现像 <code>public final class String</code> 、<code>public final class Math</code> 、<code>public final class Scanner</code> 等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。</p>
<h3 id="4-2-2-修饰方法"><a href="#4-2-2-修饰方法" class="headerlink" title="4.2.2 修饰方法"></a>4.2.2 修饰方法</h3><p>final修饰的方法，不能被重写。<br>格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">final</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu2</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Fu2 show1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Fu2 show2&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi2</span> <span class="keyword">extends</span> <span class="title class_">Fu2</span> &#123;</span><br><span class="line"><span class="comment">//	@Override</span></span><br><span class="line"><span class="comment">//	public void show1() &#123;</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;Zi2 show1&quot;);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Zi2 show2&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/post/cd36ea51/image-20231125165759409-170124144611821.png" class="" title="image-20231125165759409"> 

<h3 id="4-2-3-修饰变量-局部变量"><a href="#4-2-3-修饰变量-局部变量" class="headerlink" title="4.2.3 修饰变量-局部变量"></a>4.2.3 修饰变量-局部变量</h3><ol>
<li><strong>局部变量——基本类型</strong><br>基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 声明变量，使用final修饰</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> a;</span><br><span class="line">        <span class="comment">// 第一次赋值 </span></span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 第二次赋值</span></span><br><span class="line">        a = <span class="number">20</span>; <span class="comment">// 报错,不可重新赋值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明变量，直接赋值，使用final修饰</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 第二次赋值</span></span><br><span class="line">        b = <span class="number">20</span>; <span class="comment">// 报错,不可重新赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考，下面两种写法，哪种可以通过编译？</p>
<p>写法1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    c = i;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> i;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 <code>final</code> 的定义，写法1报错！写法2，为什么通过编译呢？因为每次循环，都是一次新的变量c。这也是大家需要注意的地方。</p>
<h3 id="4-2-4-修饰变量-成员变量"><a href="#4-2-4-修饰变量-成员变量" class="headerlink" title="4.2.4 修饰变量-成员变量"></a>4.2.4 修饰变量-成员变量</h3><p>&#x3D;&#x3D;成员变量涉及到初始化的问题，初始化方式有显示初始化和构造方法初始化，只能选择其中一个：&#x3D;&#x3D;</p>
<ul>
<li>显示初始化(在定义成员变量的时候立马赋值)（常用）；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>构造方法初始化(在构造方法中赋值一次)（不常用，了解即可）。</p>
</li>
<li><img src="java1-0/image-20231125170144515-170124144611822.png" alt="image-20231125170144515" style="zoom:50%;" /> 

<p><strong>注意：每个构造方法中都要赋值一次！</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> num2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num2 = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//     this.num2 = 20;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num2 = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//     this.num2 = 20;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>被final修饰的常量名称，一般都有书写规范，所有字母都<strong>大写</strong>。</p>
</blockquote>
<h2 id="final关键字总结"><a href="#final关键字总结" class="headerlink" title="final关键字总结"></a>final关键字总结</h2><blockquote>
<p><code>final</code> 是Java中的关键字，它可以用于修饰类、方法、变量等，表示不可改变的。</p>
<ol>
<li><p><strong>final 修饰变量：</strong> 使用 <code>final</code> 修饰的变量表示常量，一旦赋值后不可再修改。</p>
<p>&#x3D;&#x3D;常量通常使用大写字母命名，多个单词用下划线分隔。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_VALUE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>final 修饰方法：</strong> 使用 <code>final</code> 修饰的方法表示该方法不可被子类重写（覆盖）。</p>
<p>子类无法改变 <code>final</code> 方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// final方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 无法重写 finalMethod</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>final 修饰类：</strong> 使用 <code>final</code> 修饰的类表示该类不可被继承。</p>
<p>不能有其他类继承这个被 <code>final</code> 修饰的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FinalClass</span> &#123;</span><br><span class="line">    <span class="comment">// 类的定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法继承 FinalClass</span></span><br><span class="line"><span class="comment">// public class ChildClass extends FinalClass &#123;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>final 修饰成员变量：</strong> 对于非基本数据类型的成员变量（即引用类型），<code>final</code> 表示该引用不可变</p>
<p>也就是mylist这辈子就指定<code>new ArrayList&lt;&gt;()</code>了</p>
<p>但是对象的状态（属性）是可以改变的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; myList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>myList</code> 引用不能再指向其他 <code>List</code> 对象，但是 <code>myList</code> 中的元素可以被修改。</p>
</li>
<li><p><strong>final 参数：</strong> 在方法的参数中使用 <code>final</code> 修饰，表示该参数在方法中不可被修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// value 不可被修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>final 关键字的性能优化：</strong> 在某些情况下，<code>final</code> 修饰的变量对于编译器来说是一个常量，可以进行一些优化，例如内联。这有助于提高代码的执行效率。</p>
</li>
</ol>
<p><code>final</code> 关键字用于表示不可变性，可以应用于变量、方法、类等。</p>
<p>使用 <code>final</code> 有助于提高代码的可读性、安全性，并且在一些情况下可以进行性能优化。</p>
</blockquote>
<h1 id="抽象类-接口-内部类★★★"><a href="#抽象类-接口-内部类★★★" class="headerlink" title="&#x3D;&#x3D;抽象类&amp;接口&amp;内部类★★★&#x3D;&#x3D;"></a>&#x3D;&#x3D;抽象类&amp;接口&amp;内部类★★★&#x3D;&#x3D;</h1><ul>
<li><input disabled="" type="checkbox"> 能够写出抽象类的格式</li>
<li><input disabled="" type="checkbox"> 能够写出抽象方法的格式</li>
<li><input disabled="" type="checkbox"> 能说出抽象类的应用场景</li>
<li><input disabled="" type="checkbox"> 写出定义接口的格式</li>
<li><input disabled="" type="checkbox"> 写出实现接口的格式</li>
<li><input disabled="" type="checkbox"> 说出接口中成员的特点</li>
<li><input disabled="" type="checkbox"> 能说出接口的应用场景</li>
<li><input disabled="" type="checkbox"> 能说出接口中为什么会出现带有方法体的方法</li>
<li><input disabled="" type="checkbox"> 能完成适配器设计模式</li>
</ul>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><blockquote>
<ol>
<li>抽象类（Abstract Class）：</li>
</ol>
<ul>
<li>抽象类是通过使用关键字<code>abstract</code>来定义的。</li>
<li>抽象类不能被实例化，&#x3D;&#x3D;只能作为父类被继承。&#x3D;&#x3D;</li>
<li>抽象方法没有具体的实现，需要子类进行实现。</li>
<li>子类继承抽象类时，必须实现抽象类中的所有抽象方法，除非子类也是抽象类。</li>
<li><img src="java1-0/image-20231125210047489-170124144611823.png" alt="image-20231125210047489" style="zoom:50%;" /></li>
</ul>
</blockquote>
<h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><h3 id="1-1-1-抽象类引入"><a href="#1-1-1-抽象类引入" class="headerlink" title="1.1.1 抽象类引入"></a>1.1.1 抽象类引入</h3><p>​	父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。</p>
<p>换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类只需要提供一个没有方法体的定义即可，具体实现交给子类自己去实现。</p>
<p>**我们把&#x3D;&#x3D;没有方法体的方法&#x3D;&#x3D;称为抽象方法。Java语法规定，&#x3D;&#x3D;包含抽象方法的类就是抽象类&#x3D;&#x3D;**。</p>
<p>&#x3D;&#x3D;或者简单的加上关键字也是抽象类，但是不一定有抽象方法&#x3D;&#x3D;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span></span>;</span><br><span class="line">这就是一个抽象方法;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">这不是抽象方法，而是一个空实现的函数;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>抽象方法</strong> ： 没有方法体的方法。</li>
<li><strong>抽象类</strong>：包含抽象方法的类。</li>
</ul>
<blockquote>
<p>&#x3D;&#x3D;含抽象方法的一定是抽象类&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;抽象类不一定有抽象方法&#x3D;&#x3D;</p>
</blockquote>
<h2 id="1-2-abstract使用格式"><a href="#1-2-abstract使用格式" class="headerlink" title="1.2 abstract使用格式"></a>1.2 abstract使用格式</h2><p><strong>abstract是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类。</strong></p>
<blockquote>
<p>有抽象方法的类就是抽象类</p>
<p>final&#x2F;static&#x2F;abstract都是放修饰词的后面</p>
</blockquote>
<h3 id="1-2-1-抽象方法"><a href="#1-2-1-抽象方法" class="headerlink" title="1.2.1 抽象方法"></a>1.2.1 抽象方法</h3><p>使用<code>abstract</code> 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名 (参数列表);</span><br></pre></td></tr></table></figure>

<p>代码举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Eat</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-抽象类"><a href="#1-2-2-抽象类" class="headerlink" title="1.2.2 抽象类"></a>1.2.2 抽象类</h3><p>如果一个类包含抽象方法，那么该类必须是抽象类。</p>
<p>&#x3D;&#x3D;<strong>注意：抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类。</strong>&#x3D;&#x3D;</p>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> class 类名字 &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-抽象类的使用"><a href="#1-2-3-抽象类的使用" class="headerlink" title="1.2.3 抽象类的使用"></a>1.2.3 抽象类的使用</h3><p><strong>要求</strong>：&#x3D;&#x3D;<strong>继承</strong>抽象类的子类<strong>必须重写父类所有的抽象方法</strong>。&#x3D;&#x3D;</p>
<p>》 》》而不是要重写所有方法</p>
<p>而且重写的时候不加<code>abstract</code></p>
<blockquote>
<p>也就是说如果继承了抽象类，要重写，就把所有的抽象方法都重写&#x2F;实现了，实现了就可以不抽象了</p>
<p>要不重写，拿自己也要不变成抽象类了，因为也包含继承下来的抽象方法了。</p>
<hr>
<p>更详细地解释一下：</p>
<ol>
<li><p><strong>&#x3D;&#x3D;继承抽象类并实现抽象方法&#x3D;&#x3D;：</strong> 如果一个类继承了抽象类</p>
<p>那么它必须要么自己也是一个抽象类，要么实现（重写）抽象类中的所有抽象方法。</p>
<p>&#x3D;&#x3D;一个类只有在实现了所有抽象方法之后才能被实例化。&#x3D;&#x3D;</p>
<p>一旦一个类实现了抽象类中的所有抽象方法，它就不再是抽象的，可以被实例化和使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他非抽象方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>&#x3D;&#x3D;<strong>不重写抽象方法：</strong>&#x3D;&#x3D;如果一个类继承了抽象类但没有实现所有的抽象方法</p>
<p>那么这个类也必须声明为抽象类。这样，它的子类可以选择性地实现这些抽象方法，或者它自己也可以继续保持抽象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 其他抽象方法...</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AnotherAbstractClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">// 不重写所有抽象方法，所以仍然是抽象类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 其他抽象方法...</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AnotherAbstractClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 其他抽象方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>继承抽象类的子类要么实现抽象方法，要么自己也声明为抽象类。</p>
<p>确保了抽象类的抽象方法在整个继承层次中得到实现，从而使得最终的子类是可以实例化和使用的。</p>
</blockquote>
<p>否则，该子类也必须声明为抽象类.</p>
<p>代码举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类,抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String id, String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 抽象方法</span></span><br><span class="line">	<span class="comment">// 抽象方法必须要放在抽象类中</span></span><br><span class="line">	<span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个子类继承抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String id, String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(id, name, salary);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2.重写父类的抽象方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;管理其他人&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个子类继承抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cook</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Cook</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Cook</span><span class="params">(String id, String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(id, name, salary);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;厨师炒菜多加点盐...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建抽象类,抽象类不能创建对象</span></span><br><span class="line">		<span class="comment">// 假设抽象类让我们创建对象,里面的抽象方法没有方法体,无法执行.所以不让我们创建对象</span></span><br><span class="line"><span class="comment">//		Employee e = new Employee();</span></span><br><span class="line"><span class="comment">//		e.work();</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 3.创建子类</span></span><br><span class="line">		<span class="type">Manager</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">		m.work();</span><br><span class="line">		</span><br><span class="line">		<span class="type">Cook</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cook</span>(<span class="string">&quot;ap002&quot;</span>, <span class="string">&quot;库克&quot;</span>, <span class="number">1</span>);</span><br><span class="line">		c.work();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p>
<hr>
<h2 id="1-3-抽象类的特征"><a href="#1-3-抽象类的特征" class="headerlink" title="1.3 抽象类的特征"></a>1.3 抽象类的特征</h2><p>抽象类的特征总结起来可以说是 <strong>有得有失</strong></p>
<p><strong>有得：抽象类得到了拥有抽象方法的能力。</strong></p>
<p><strong>有失：抽象类失去了创建对象的能力。</strong></p>
<p>其他成员（构造方法，实例方法，静态方法等）抽象类都是具备的。</p>
<h2 id="1-4-抽象类的细节"><a href="#1-4-抽象类的细节" class="headerlink" title="1.4 抽象类的细节"></a>1.4 抽象类的细节</h2><p>不需要背，只要当idea报错之后，知道如何修改即可。</p>
<p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p>
<ol>
<li><p>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p>
<blockquote>
<p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>
</blockquote>
</li>
<li><p>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p>
<blockquote>
<p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p>
</blockquote>
</li>
<li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p>
<blockquote>
<p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错&#x3D;&#x3D;</p>
<blockquote>
<p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;抽象类存在的意义是为了被子类继承。&#x3D;&#x3D;</p>
<blockquote>
<p>理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。</p>
</blockquote>
</li>
</ol>
<h2 id="1-5-抽象类存在的意义"><a href="#1-5-抽象类存在的意义" class="headerlink" title="1.5 抽象类存在的意义"></a>1.5 抽象类存在的意义</h2><p>​	抽象类存在的意义是为了被子类继承，否则抽象类将毫无意义。</p>
<p>抽象类可以&#x3D;&#x3D;<strong>强制让子类</strong>，一定要按照规定的格式进行重写。&#x3D;&#x3D;</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><blockquote>
<p>接口（Interface）&#x3D;&#x3D;是一种抽象类型&#x3D;&#x3D;，<strong>它定义了一组抽象方法</strong>，但不能包含具体的实现。</p>
<p>接口提供了一种多继承机制，一个类可以实现多个接口。以下是关于Java接口的核心知识：</p>
<ol>
<li><p><strong>定义接口：</strong> 使用 <code>interface</code> 关键字来定义接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>; <span class="comment">// 抽象方法，不包含方法体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口中可以包含常量（实际上是静态常量）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">MAX_VALUE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实现接口：</strong> 使用 <code>implements</code> 关键字，一个类可以实现一个或多个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现接口中的抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多继承：</strong> 一个类可以同时实现多个接口，从而实现多继承的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyOtherClass</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span>, AnotherInterface &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现 MyInterface 中的抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">anotherAbstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现 AnotherInterface 中的抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>默认方法和静态方法：</strong> Java 8 引入了接口中的默认方法（default method）和静态方法（static method）。默认方法允许在接口中提供方法的默认实现，而静态方法是在接口级别上的工具方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>; <span class="comment">// 默认抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 默认方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类可以选择性地重写默认方法，但不能重写静态方法。</p>
</li>
<li><p><strong>常量：</strong> 接口中的变量默认是常量，即使用 <code>final</code> 和 <code>static</code> 修饰的变量，其值在接口中被设定，并且不能在实现类中修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">MAX_VALUE</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 常量</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<blockquote>
<ul>
<li>接口是通过使用关键字<code>interface</code>来定义的。</li>
<li>&#x3D;&#x3D;接口定义了一组相关的方法，但没有具体的实现。&#x3D;&#x3D;</li>
<li>类可以实现一个或多个接口，通过关键字<code>implements</code>来实现接口。</li>
<li>实现接口的类必须提供接口中定义的所有方法的实现。因为全是抽象的要去实现</li>
<li>&#x3D;&#x3D;接口可以包含常量、抽象方法、默认方法和静态方法&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>我们已经学完了抽象类，抽象类中可以用抽象方法，也可以有普通方法，构造方法，成员变量等。</p>
<blockquote>
<p>接口是更加彻底的抽象——-接口中全部是抽象方法</p>
</blockquote>
<p>那么什么是接口呢？<strong>接口是更加彻底的抽象，JDK7之前，包括JDK7，接口中全部是抽象方法。接口同样是不能创建对象的</strong>。</p>
<p>&#x3D;&#x3D;抽象类都是不能被实例化的&#x3D;&#x3D;</p>
<p>接口不能直接实例化，只能通过实现该接口的类来创建对象。</p>
<p>一个类可以实现多个接口，从而具备多个接口定义的行为</p>
<h2 id="2-2-定义格式"><a href="#2-2-定义格式" class="headerlink" title="2.2 定义格式"></a>2.2 定义格式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口的定义格式：</span></span><br><span class="line">修饰词 interface 接口名称&#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口的声明：interface</span></span><br><span class="line"><span class="comment">// 接口名称：首字母大写，满足“驼峰模式”</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-接口成分的特点"><a href="#2-3-接口成分的特点" class="headerlink" title="&#x3D;&#x3D;2.3 接口成分的特点&#x3D;&#x3D;"></a>&#x3D;&#x3D;2.3 接口成分的特点&#x3D;&#x3D;</h2><p>**<img src="java1-0/image-20231129102236587.png" alt="image-20231129102236587" style="zoom: 50%;" /> **</p>
<blockquote>
<p>Java接口中的方法默认是public和abstract的。如果在接口中不显式指定访问修饰符，默认为public；如果不显式指定方法为抽象方法（abstract），也会被默认为抽象方法。</p>
<p>因此，下面两个接口方法声明是等价的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在接口中定义的方法不包含方法体（实现），而是由&#x3D;&#x3D;<strong>实现该接口的类来提供具体的实现</strong>&#x3D;&#x3D;。在Java 8及以后的版本，接口还引入了默认方法和静态方法，允许在接口中提供具体的实现。</p>
<p>默认方法使用<code>default</code>关键字声明，而静态方法使用<code>static</code>关键字声明。这些特性让接口更加灵活，能够适应新的编程模型。</p>
<img src="/post/cd36ea51/image-20231129103539639.png" class="" title="image-20231129103539639"> 
</blockquote>
<p>  在JDK7，包括JDK7之前，接口中的<strong>只有</strong>包含：抽象方法和常量</p>
<h3 id="2-3-1-抽象方法"><a href="#2-3-1-抽象方法" class="headerlink" title="2.3.1.抽象方法"></a>2.3.1.抽象方法</h3><p>​       注意：&#x3D;&#x3D;<strong>接口中的抽象方法默认会自动加上public abstract修饰程序员无需自己手写！！</strong>&#x3D;&#x3D;</p>
<p>但是重写的时候就得带上publicl了！！！</p>
<p>​       按照规范：以后接口中的抽象方法建议不要写上public abstract。因为没有必要啊，默认会加上。</p>
<h3 id="2-3-2-常量"><a href="#2-3-2-常量" class="headerlink" title="2.3.2 常量"></a>2.3.2 常量</h3><p> 在接口中定义的成员变量&#x3D;&#x3D;默认会加上&#x3D;&#x3D;： public static final修饰。也就是说在接口中定义的成员变量实际上是一个常量。这里是使用public static final修饰后，变量值就不可被修改，并且是静态化的变量可以直接用接口名访问，所以也叫常量。</p>
<p>&#x3D;&#x3D;常量必须要给初始值&#x3D;&#x3D;。常量命名规范建议字母全部大写，多个单词用下划线连接。</p>
<h3 id="2-3-3-案例演示"><a href="#2-3-3-案例演示" class="headerlink" title="2.3.3 案例演示"></a>2.3.3 案例演示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterF</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法！</span></span><br><span class="line">    <span class="comment">//    public abstract void run();</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    public abstract String getName();</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    public abstract int add(int a , int b);</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 它的最终写法是：</span></span><br><span class="line">    <span class="comment">// public static final int AGE = 12 ;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">AGE</span>  <span class="operator">=</span> <span class="number">12</span>; <span class="comment">//常量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;黑马程序员&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="default，static关键字，私有方法"><a href="#default，static关键字，私有方法" class="headerlink" title="default，static关键字，私有方法"></a>default，static关键字，私有方法</h2><h3 id="Default"><a href="#Default" class="headerlink" title="Default"></a>Default</h3><img src="/post/cd36ea51/image-20231129105956830.png" class="" title="image-20231129105956830">

<img src="java1-0/image-20231129110549076.png" alt="image-20231129110549076" style="zoom:50%;" /> 

<h3 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h3><p>只能用接口.去调用</p>
<p>因为是属于接口这个类的</p>
<img src="/post/cd36ea51/image-20231129111030363.png" class="" title="image-20231129111030363"> 

<blockquote>
<p><code>default</code> 关键字是Java 8引入的一个特性</p>
<p>主要用于在接口中定义默认方法（Default Methods）。</p>
<p>&#x3D;&#x3D;默认方法是指<strong>接口可以提供一个具体的方法实现</strong>，而<strong>不需要实现该接口的所有类都必须显式地提供实现</strong>。&#x3D;&#x3D;</p>
<ol>
<li><p><strong>默认方法的定义：</strong> 在接口中使用 <code>default</code> 关键字来定义默认方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">regularMethod</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 默认方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，<code>defaultMethod</code> 是一个默认方法，提供了默认的实现。实现该接口的类可以选择性地重写这个方法。</p>
</li>
<li><p><strong>实现类的处理：</strong> &#x3D;&#x3D;如果实现类不提供对默认方法的具体实现，将自动继承接口中的默认实现。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regularMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不提供 defaultMethod 的实现，将继承 MyInterface 中的默认实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>冲突解决：</strong> 如果一个类实现了多个接口，并且这些接口中都包含相同的默认方法，编译器会报告冲突。此时，实现类必须显式地提供对冲突方法的实现，以解决冲突。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceA</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">commonMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;InterfaceA&#x27;s default implementation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceB</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">commonMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;InterfaceB&#x27;s default implementation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConcreteClass</span> <span class="keyword">implements</span> <span class="title class_">InterfaceA</span>, InterfaceB &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commonMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 解决冲突，提供具体实现</span></span><br><span class="line">        System.out.println(<span class="string">&quot;MyConcreteClass&#x27;s implementation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>接口中的静态方法：</strong> 除了默认方法，还有接口中的静态方法，使用 <code>static</code> 关键字声明。</p>
<p>&#x3D;&#x3D;接口中的静态方法可以直接通过接口名调用，而不需要实现类的实例。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>静态私有方法给静态的方法服务</p>
<p>非静态的私有方法给公共方法服务</p>
<img src="/post/cd36ea51/image-20231129111516919.png" class="" title="image-20231129111516919">

<img src="java1-0/image-20231129111523437.png" alt="image-20231129111523437" style="zoom:50%;" /> 

<img src="java1-0/image-20231129111730617.png" alt="image-20231129111730617" style="zoom:50%;" />   

<img src="java1-0/image-20231129111739131.png" alt="image-20231129111739131" style="zoom:50%;" /> 



<h2 id="接口和类之间的-关系"><a href="#接口和类之间的-关系" class="headerlink" title="接口和类之间的 关系"></a>接口和类之间的 关系</h2><img src="/post/cd36ea51/image-20231129103929345.png" class="" title="image-20231129103929345"> 

<p>实现的多个接口中同名且同参的方法  只要重写一次就行, 但是同名不同参的视为两个不同的方法 <strong>都要重写</strong></p>
<p>相当于会自动合并</p>
<img src="/post/cd36ea51/image-20231129104503859.png" class="" title="image-20231129104503859">



<p>&#x3D;&#x3D;接口之间的继承的时候，要把继承下来的所有都要重写&#x3D;&#x3D;</p>
<img src="/post/cd36ea51/image-20231129104737528.png" class="" title="image-20231129104737528">  

<h2 id="2-4-基本的实现"><a href="#2-4-基本的实现" class="headerlink" title="2.4 基本的实现"></a>2.4 基本的实现</h2><h3 id="2-4-1-实现接口-的概述"><a href="#2-4-1-实现接口-的概述" class="headerlink" title="2.4.1 &#x3D;&#x3D;实现接口&#x3D;&#x3D;的概述"></a>2.4.1 &#x3D;&#x3D;实现接口&#x3D;&#x3D;的概述</h3><p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类，也可以称为接口的子类。</p>
<p>实现的动作&#x3D;&#x3D;类似继承&#x3D;&#x3D;，&#x3D;&#x3D;格式相仿&#x3D;&#x3D;，只是关键字不同，实现使用 <code> implements</code>关键字。</p>
<p>一个类帮忙实现了接口，那么类似继承，也是可以使用自己实现的方法的</p>
<h3 id="2-4-2-实现接口的格式"><a href="#2-4-2-实现接口的格式" class="headerlink" title="2.4.2 实现接口的格式"></a>2.4.2 实现接口的格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**接口的实现：</span></span><br><span class="line"><span class="comment">    在Java中接口是被实现的，实现接口的类称为实现类。</span></span><br><span class="line"><span class="comment">    实现类的格式:*/</span></span><br><span class="line">class 类名 implements 接口<span class="number">1</span>,接口<span class="number">2</span>,接口<span class="number">3.</span>..&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面格式可以看出，接口是可以被多实现的。大家可以想一想为什么呢？</p>
<blockquote>
<p>通过&#x3D;&#x3D;允许一个类实现多个接口&#x3D;&#x3D;</p>
<p>但不是多继承，java是不允许多继承的</p>
<p>&#x3D;&#x3D;在不同的接口中定义不同的行为，使得实现类能够具备多种功能。这种设计方式称为接口的多继承。&#x3D;&#x3D;</p>
</blockquote>
<h3 id="2-4-3-类实现接口的要求和意义"><a href="#2-4-3-类实现接口的要求和意义" class="headerlink" title="2.4.3 类实现接口的要求和意义"></a>2.4.3 类实现接口的要求和意义</h3><blockquote>
<ol>
<li>必须重写实现的全部接口中所有抽象方法。</li>
<li>如果一个类实现了接口，&#x3D;&#x3D;但是没有重写完全部接口的全部抽象方法，这个类也必须定义成抽象类。&#x3D;&#x3D;</li>
<li><strong>意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。</strong></li>
</ol>
</blockquote>
<h3 id="2-4-4-类与接口基本实现案例"><a href="#2-4-4-类与接口基本实现案例" class="headerlink" title="2.4.4  类与接口基本实现案例"></a>2.4.4  类与接口基本实现案例</h3><p>假如我们定义一个运动员的<strong>接口</strong>（规范），代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   接口：接口体现的是规范。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SportMan</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; <span class="comment">// 抽象方法，跑步。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">law</span><span class="params">()</span>; <span class="comment">// 抽象方法，遵守法律。</span></span><br><span class="line">    String <span class="title function_">compittion</span><span class="params">(String project)</span>;  <span class="comment">// 抽象方法，比赛。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来定义一个乒乓球运动员类，实现接口，实现接口的<strong>实现类</strong>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima._03接口的实现;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口的实现：</span></span><br><span class="line"><span class="comment"> *    在Java中接口是被实现的，实现接口的类称为实现类。</span></span><br><span class="line"><span class="comment"> *    实现类的格式:</span></span><br><span class="line"><span class="comment"> *      class 类名 implements 接口1,接口2,接口3...&#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PingPongMan</span>  <span class="keyword">implements</span> <span class="title class_">SportMan</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;乒乓球运动员稍微跑一下！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">law</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;乒乓球运动员守法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">compittion</span><span class="params">(String project)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;参加&quot;</span>+project+<span class="string">&quot;得金牌！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建实现类对象。</span></span><br><span class="line">        <span class="type">PingPongMan</span> <span class="variable">zjk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PingPongMan</span>();</span><br><span class="line">        zjk.run();</span><br><span class="line">        zjk.law();</span><br><span class="line">        System.out.println(zjk.compittion(<span class="string">&quot;全球乒乓球比赛&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-5-类与接口的-多实现-案例"><a href="#2-4-5-类与接口的-多实现-案例" class="headerlink" title="2.4.5 类与接口的&#x3D;&#x3D;多实现&#x3D;&#x3D;案例"></a>2.4.5 类与接口的&#x3D;&#x3D;多实现&#x3D;&#x3D;案例</h3><p><strong>类与接口之间的关系是多实现的，一个类可以同时实现多个接口。</strong></p>
<p>首先我们先定义两个接口，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 法律规范：接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Law</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rule</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 这一个运动员的规范：接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SportMan</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后定义一个实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java中接口是可以被多实现的：</span></span><br><span class="line"><span class="comment"> *    一个类可以实现多个接口: Law, SportMan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JumpMan</span> <span class="keyword">implements</span> <span class="title class_">Law</span> ,SportMan &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rule</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;尊长守法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;训练跑步！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出类与接口之间是可以多实现的，我们可以理解成实现多个规范，这是合理的。</p>
<h2 id="2-5-接口与接口的多继承"><a href="#2-5-接口与接口的多继承" class="headerlink" title="2.5 接口与接口的多继承"></a>2.5 接口与接口的多继承</h2><p>Java中，接口与接口之间是可以多继承的：也就是一个接口可以同时继承多个接口。大家一定要注意：</p>
<blockquote>
<blockquote>
<p><strong>类与接口是实现关系</strong></p>
<p><strong>接口与接口是继承关系</strong></p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>&#x3D;&#x3D;接口继承接口就是把其他接口的抽象方法与本接口进行了合并。&#x3D;&#x3D;</strong></p>
</blockquote>
<p>案例演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Abc</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 法律规范：接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Law</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rule</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> *</span><br><span class="line"> *  总结：</span><br><span class="line"> *     接口与类之间是多实现的。</span><br><span class="line"> *     接口与接口之间是多继承的。</span><br><span class="line"> * */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SportMan</span> <span class="keyword">extends</span> <span class="title class_">Law</span> , Abc &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6扩展：接口的细节"><a href="#2-6扩展：接口的细节" class="headerlink" title="2.6扩展：接口的细节"></a>2.6扩展：接口的细节</h2><p>不需要背，只要当idea报错之后，知道如何修改即可。</p>
<p>关于接口的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p>
<ol>
<li>当两个接口中存在相同抽象方法的时候，该怎么办？</li>
</ol>
<blockquote>
<p>只要重写一次即可。此时重写的方法，既表示重写1接口的，也表示重写2接口的。</p>
</blockquote>
<ol start="2">
<li>实现类能不能继承A类的时候，同时实现其他接口呢？</li>
</ol>
<blockquote>
<p>继承的父类，就好比是亲爸爸一样<br>实现的接口，就好比是干爹一样<br>可以继承一个类的同时，再实现多个接口，只不过，要把接口里面所有的抽象方法，全部实现。</p>
<p>&#x3D;&#x3D;先继承后实现接口&#x3D;&#x3D;</p>
<img src="java1-0/image-20231125203433779-170124144611824.png" alt="image-20231125203433779" style="zoom:50%;" /> 
</blockquote>
<ol start="3">
<li>实现类能不能继承一个抽象类的时候，同时实现其他接口呢？</li>
</ol>
<blockquote>
<p>实现类可以继承一个抽象类的同时，再实现其他多个接口，只不过要把里面所有的抽象方法全部重写。</p>
</blockquote>
<ol start="4">
<li>实现类Zi，实现了一个接口，还继承了一个Fu类。假设在接口中有一个方法，父类中也有一个相同的方法。子类如何操作呢？</li>
</ol>
<blockquote>
<p>处理办法一：如果父类中的方法体，能满足当前业务的需求，在子类中可以不用重写。<br>处理办法二：如果父类中的方法体，不能满足当前业务的需求，需要在子类中重写。</p>
</blockquote>
<ol start="5">
<li>如果一个接口中，有10个抽象方法，但是我在实现类中，只需要用其中一个，该怎么办?</li>
</ol>
<blockquote>
<p>当一个接口中有多个抽象方法，而实现类只需要使用其中的一个或部分时，可以使用适配器模式来简化实现类的代码。适配器模式允许我们创建一个中间类（适配器），该类实现接口并提供默认实现，而实现类只需要继承适配器并重写需要的方法。</p>
<p>让我们通过一个例子来理解适配器模式的原理，假设有一个接口 <code>MyInterface</code>，它有多个抽象方法，但实现类 <code>MyClass</code> 只需要实现其中的一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span>;</span><br><span class="line"> <span class="comment">// ... 其他方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类只需要使用其中的 method1 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 实现 method1 方法</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 实现 method2 和 method3 方法（即使我们不需要它们）</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 不需要的实现</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 不需要的实现</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，可以使用适配器模式来简化实现类。首先，创建一个适配器类 <code>MyAdapter</code> 实现接口，为所有抽象方法提供默认实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdapter</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 提供默认实现</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 提供默认实现</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 提供默认实现</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，实现类只需要继承适配器，并重写需要的方法即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_">MyAdapter</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 实现实际需要的 method1 方法</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，实现类就只需要关注自己需要的方法，而不必强制性地实现所有抽象方法。适配器模式通过提供默认实现来减轻实现类的负担，使得代码更加简洁和易读。</p>
</blockquote>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><img src="/post/cd36ea51/image-20231129112500842.png" class="" title="image-20231129112500842">

<img src="/post/cd36ea51/image-20231129112801892.png" class="" title="image-20231129112801892"> 



<h2 id="接口总结"><a href="#接口总结" class="headerlink" title="接口总结"></a>接口总结</h2><img src="java1-0/image-20231129112033077.png" alt=" " style="zoom:50%;" /> 

<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="3-1-快速上手"><a href="#3-1-快速上手" class="headerlink" title="3.1 快速上手"></a>3.1 快速上手</h2><img src="/post/cd36ea51/image-20231129113048655.png" class="" title="image-20231129113048655"> 

<img src="/post/cd36ea51/image-20231129113355558.png" class="" title="image-20231129113355558"> 

<p>内部类是public修饰的时候</p>
<p>外部可以直接像使用类那样使用<code>Inner =new Inner();</code></p>
<p>private修饰的时候就只能通过外部类的方法来返回一个内部类了</p>
<img src="java1-0/image-20231129120927860.png" alt="image-20231129120927860" style="zoom:50%;" /> 

<h3 id="3-1-1-什么是内部类"><a href="#3-1-1-什么是内部类" class="headerlink" title="3.1.1 什么是内部类"></a>3.1.1 什么是内部类</h3><p>将一个类A定义在另一个类B里面，里面的那个类A就称为<strong>内部类</strong>，B则称为<strong>外部类</strong>。</p>
<p>&#x3D;&#x3D;可以把内部类理解成寄生，外部类理解成宿主。&#x3D;&#x3D;</p>
<h3 id="3-1-2-什么时候使用内部类"><a href="#3-1-2-什么时候使用内部类" class="headerlink" title="3.1.2 什么时候使用内部类"></a>3.1.2 什么时候使用内部类</h3><p>一个事物内部还有一个独立的事物，&#x3D;&#x3D;内部的事物脱离外部的事物无法独立使用&#x3D;&#x3D;</p>
<ol>
<li><p>人里面有一颗心脏。</p>
</li>
<li><p>汽车内部有一个发动机。</p>
</li>
<li><p>为了实现更好的封装性。</p>
</li>
</ol>
<h2 id="3-2-内部类的分类"><a href="#3-2-内部类的分类" class="headerlink" title="3.2 内部类的分类"></a>3.2 内部类的分类</h2><img src="java1-0/image-20231129113620672.png" alt="image-20231129113620672" style="zoom:50%;" /> 

<blockquote>
<p>内部类是定义在其他类内部的类。它们是一种嵌套类的形式，具有访问外部类成员和提供封装的特性。</p>
<ol>
<li><p>访问权限：&#x3D;&#x3D;<strong>内部类可以访问外部类的所有成员，包括私有成员。</strong>&#x3D;&#x3D;这种访问权限的特点使得内部类能够很方便地与外部类进行交互。</p>
</li>
<li><p>封装性：&#x3D;&#x3D;内部类可以使用private修饰，使得它们只能在外部类中访问&#x3D;&#x3D;。这样可以有效地隐藏内部实现细节，并将相关的功能封装在一起。</p>
</li>
<li><p>关联性：内部类通常用于表示外部类的一种关联关系。</p>
</li>
<li><p>实例化和访问：&#x3D;&#x3D;内部类的实例化<strong>必须在外部类的实例化之后进行</strong>&#x3D;&#x3D;，因为内部类的生命周期依赖于外部类对象。通过外部类的实例，可以访问内部类的构造方法和成员。</p>
</li>
<li><p>类型：根据定义的位置和作用域，Java的内部类有几种类型：</p>
<ul>
<li>成员内部类（Member Inner Class）：定义在外部类的成员位置，可以访问外部类的所有成员。</li>
<li>静态嵌套类（Static Nested Class）：定义在外部类的静态成员位置，可以直接通过外部类来创建实例。</li>
<li>方法内部类（Local Inner Class）：定义在方法内部，且只能在方法内部访问，通常用于解决某个具体问题。</li>
<li>匿名内部类（Anonymous Inner Class）：没有名称的内部类，通常作为接口的实现或继承某个类的子类。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="3-3-成员内部类"><a href="#3-3-成员内部类" class="headerlink" title="3.3 成员内部类"></a>3.3 成员内部类</h2><p><strong>成员内部类特点</strong>：</p>
<ul>
<li>无static修饰的内部类，属于外部类对象的。</li>
<li>宿主：外部类对象。</li>
</ul>
<p><strong>内部类的使用格式</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类.内部类。 <span class="comment">// 访问内部类的类型都是用 外部类.内部类</span></span><br></pre></td></tr></table></figure>

<p><strong>获取成员内部类对象的两种方式</strong>：</p>
<p>方式一：外部直接创建成员内部类的对象,要求public class内部对象<code>package soft1;</code>否则在类外是访问不到Hert的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soft1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Hert</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Hert</span><span class="params">(String verson)</span> &#123;</span><br><span class="line">            Verson = verson;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String Verson;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Say</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Person.<span class="built_in">this</span>.age+Person.<span class="built_in">this</span>.name+<span class="built_in">this</span>.Verson+<span class="string">&quot;正在运作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过成员函数返回。。。</span></span><br><span class="line">    <span class="keyword">public</span> Hert <span class="title function_">getinstnceof</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Hert</span>(<span class="string">&quot;9.0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soft1;</span><br><span class="line"><span class="comment">//Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Person.Hert hert=new Person(13,&quot;牛马&quot;).new Hert(&quot;2.0心脏&quot;);</span></span><br><span class="line"><span class="comment">//        hert.Say();</span></span><br><span class="line">        Person p=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">12</span>,<span class="string">&quot;dasd&quot;</span>);</span><br><span class="line"><span class="comment">//        soft1.Person$Hert@3b07d329</span></span><br><span class="line">        System.out.println(p.getinstnceof());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类.内部类 变量 = <span class="keyword">new</span> 外部类（）.new 内部类（）;</span><br></pre></td></tr></table></figure>

<img src="/post/cd36ea51/image-20231129115459046.png" class="" title="image-20231129115459046">

<p>2.但是我需要的是Car类中的Engine类，则我需要在堆空间中的Car的内存中再开辟一块内存来存储Engine类，<br>  因为在堆中用来开辟空间的语句是new<br>  其实从内存角度也可以理解这个<strong>new嵌套</strong>吧，因为<strong>需要创建这个类的对象</strong>所以需要&#x3D;&#x3D;先开辟外部类Car的空间&#x3D;&#x3D;</p>
<p>方式二：在外部类中定义一个方法提供内部类的对象</p>
<p><strong>案例演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//  宿主：外部类对象。</span></span><br><span class="line">       <span class="comment">// Outer out = new Outer();</span></span><br><span class="line">        <span class="comment">// 创建内部类对象。</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        oi.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="comment">// 成员内部类，属于外部类对象的。</span></span><br><span class="line">    <span class="comment">// 拓展：成员内部类不能定义静态成员。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="comment">// 这里面的东西与类是完全一样的。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类中的方法被调用了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Ovject son=o.getInstance();</span><br><span class="line">        <span class="comment">//多态的使用</span></span><br><span class="line">        System.out.println(o.getInstance());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-成员内部类的细节"><a href="#3-4-成员内部类的细节" class="headerlink" title="3.4 成员内部类的细节"></a>3.4 成员内部类的细节</h2><p>编写成员内部类的注意点：</p>
<ol>
<li>成员内部类可以被一些修饰符所修饰，比如： private，默认，protected，public，static等</li>
<li>在成员内部类里面，&#x3D;&#x3D;JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量。&#x3D;&#x3D;</li>
<li>创建内部类对象时，对象中有一个隐含的Outer.this记录外部类对象的地址值。（请参见3.6节的内存图）</li>
</ol>
<p>详解：</p>
<p>​	&#x3D;&#x3D;内部类被private修饰，外界无法直接获取内部类的对象，只能通过3.3节中的方式二获取内部类的对象&#x3D;&#x3D;</p>
<p>​	</p>
<p>被其他权限修饰符修饰的内部类一般用3.3节中的方式一直接获取内部类的对象</p>
<p>​	内部类被static修饰是成员内部类中的特殊情况，叫做静态内部类下面单独学习。</p>
<p>​	&#x3D;&#x3D;内部类如果想要访问外部类的成员变量，外部类的变量必须用final修饰，JDK8以前必须手动写final&#x3D;&#x3D;，JDK8之后不需要手动写，JDK默认加上。 </p>
<h2 id="3-5-成员内部类面试题"><a href="#3-5-成员内部类面试题" class="headerlink" title="3.5 成员内部类面试题"></a>3.5 成员内部类面试题</h2><p>内部类存储有外部类对象的地址<code>外部类.this</code></p>
<img src="/post/cd36ea51/image-20231129142114448.png" class="" title="image-20231129142114448"> 

<p>请在?地方向上相应代码,以达到输出的内容</p>
<p>注意：&#x3D;&#x3D;内部类访问外部类对象的格式是：<strong>外部类名.this</strong>&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.<span class="type">inner</span> <span class="variable">oi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">inner</span>();</span><br><span class="line">        oi.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;	<span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在成员位置定义一个类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">            System.out.println(???);	<span class="comment">// 10   答案：a</span></span><br><span class="line">            System.out.println(???);	<span class="comment">// 20	答案：this.a</span></span><br><span class="line">            System.out.println(???);	<span class="comment">// 30	答案：Outer.this.a</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-成员内部类内存图"><a href="#3-6-成员内部类内存图" class="headerlink" title="3.6 成员内部类内存图"></a>3.6 成员内部类内存图</h2><blockquote>
<p><code>Outer.Inner oi=new Outer().new Inner()</code></p>
<p>先加载main方法，所需的类，<img src="/post/cd36ea51/image-20231129142315304.png" class="" title="image-20231129142315304"> </p>
<p>然后在堆区开辟空间<code>oi记录的是内部类的地址，因为 Outer().new Inner()</code></p>
<p>然后调用show方法，</p>
<blockquote>
<p>a就近原则，在方法里找</p>
<p>this.a是在内部类里面找</p>
<p>outer.this.a是在外部类找</p>
</blockquote>
</blockquote>


<h2 id="3-7-静态内部类"><a href="#3-7-静态内部类" class="headerlink" title="3.7 静态内部类"></a>3.7 静态内部类</h2><p><strong>静态内部类特点</strong>：</p>
<ul>
<li>静态内部类是一种特殊的成员内部类。</li>
</ul>
<ul>
<li><p>&#x3D;&#x3D;有static修饰，属于外部类本身的。&#x3D;&#x3D;</p>
</li>
<li><p>总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类。</p>
</li>
<li><blockquote>
<ul>
<li><strong>拓展1</strong>:静态内部类可以直接访问外部类的静态成员。</li>
<li><strong>拓展2</strong>:静态内部类不可以直接访问外部类的非静态成员，如果要访问需要创建外部类的对象。</li>
<li><strong>拓展3</strong>:&#x3D;&#x3D;静态内部类中没有的Outer.this。&#x3D;&#x3D;</li>
<li>静态类就是没有this，因为是属于类的</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>内部类的使用格式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外部类.内部类。</span><br></pre></td></tr></table></figure>

<p><strong>静态内部类对象的创建格式</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类.内部类  变量 = <span class="keyword">new</span>  外部类.内部类构造器;</span><br></pre></td></tr></table></figure>

<p><strong>调用方法的格式：</strong></p>
<ul>
<li><img src="/post/cd36ea51/image-20231129142621128.png" class="" title="image-20231129142621128"></li>
</ul>
<p><strong>案例演示</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soft1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> outerStaticField;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> outerInstanceField;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> innerStaticField;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> innerInstanceField;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 可以直接访问外部类的静态成员</span></span><br><span class="line">            outerStaticField = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 无法直接访问外部类的非静态成员，需要通过外部类的实例来访问</span></span><br><span class="line">            <span class="type">OuterClass</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">            outer.outerInstanceField = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建静态内部类的实例</span></span><br><span class="line">        <span class="type">StaticInnerClass</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以通过静态内部类的实例访问它的成员</span></span><br><span class="line">        inner.innerStaticField = <span class="number">30</span>;</span><br><span class="line">        inner.innerInstanceField = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-8-局部内部类"><a href="#3-8-局部内部类" class="headerlink" title="3.8 局部内部类"></a>3.8 局部内部类</h2><p>没有修饰词，类似局部变量</p>
<ul>
<li><strong>局部内部类</strong> ：定义在<strong>方法中</strong>的类。</li>
</ul>
<p>定义格式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 外部类名 &#123;</span><br><span class="line">	数据类型 变量名;</span><br><span class="line">	</span><br><span class="line">	修饰符 返回值类型 方法名(参数列表) &#123;</span><br><span class="line">		<span class="comment">// …</span></span><br><span class="line">		class 内部类 &#123;</span><br><span class="line">			<span class="comment">// 成员变量</span></span><br><span class="line">			<span class="comment">// 成员方法</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-9-匿名内部类【重点】"><a href="#3-9-匿名内部类【重点】" class="headerlink" title="3.9 &#x3D;&#x3D;匿名内部类【重点】&#x3D;&#x3D;"></a>3.9 &#x3D;&#x3D;匿名内部类【重点】&#x3D;&#x3D;</h2><h3 id="3-9-1-概述"><a href="#3-9-1-概述" class="headerlink" title="3.9.1 概述"></a>3.9.1 概述</h3><img src="java1-0/image-20231129144022569.png" alt="image-20231129144022569" style="zoom:67%;" /> 

<p>&#x3D;&#x3D;<strong>其实是匿名内部类的对象</strong>，真正的匿名类是蓝色圈起来的&#x3D;&#x3D; </p>
<p><strong>匿名内部类</strong> ：是内部类的简化写法。他是一个&#x3D;&#x3D;隐含了名字的内部类。&#x3D;&#x3D;</p>
<p>开发中，最常用到的内部类就是匿名内部类了。</p>
<h3 id="3-9-2-格式"><a href="#3-9-2-格式" class="headerlink" title="3.9.2 格式"></a>3.9.2 格式</h3><img src="java1-0/image-20231129145630167.png" alt="image-20231129145630167" style="zoom:50%;" /> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或者接口名() &#123;</span><br><span class="line">     重写方法;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>包含了：</p>
<ul>
<li><p>&#x3D;&#x3D;继承或者实现关系&#x3D;&#x3D;</p>
</li>
<li><p>方法重写</p>
</li>
<li><p>空参构造函数创建对象</p>
</li>
</ul>
<p>&#x3D;&#x3D;也就是  匿名类继承父类-重写方法-空参创建匿名对象一步完成而已&#x3D;&#x3D;</p>
<p>所以从语法上来讲，这个整体其实是匿名内部类对象</p>
<blockquote>
<p>不是真正的匿名了，只不过不需要我们提供名字而已，是可以在.class中看到</p>
</blockquote>
<h3 id="反编译javap-class文件"><a href="#反编译javap-class文件" class="headerlink" title="&#x3D;&#x3D;反编译javap .class文件&#x3D;&#x3D;"></a>&#x3D;&#x3D;反编译javap .class文件&#x3D;&#x3D;</h3><img src="/post/cd36ea51/image-20231129145422303.png" class="" title="image-20231129145422303">

<img src="/post/cd36ea51/image-20231129145427437.png" class="" title="image-20231129145427437">

<p>进入到当前目录，然后cmd</p>
<img src="/post/cd36ea51/image-20231129145429894.png" class="" title="image-20231129145429894">

<h3 id="3-9-2-什么时候用到匿名内部类"><a href="#3-9-2-什么时候用到匿名内部类" class="headerlink" title="3.9.2 什么时候用到匿名内部类"></a>3.9.2 什么时候用到匿名内部类</h3><p><strong>实际上，如果我们希望定义一个只要使用一次的类，就可考虑使用匿名内部类。匿名内部类的本质作用</strong></p>
<p><strong>是为了简化代码</strong>。 </p>
<p>之前我们使用接口时，似乎得做如下几步操作：</p>
<ol>
<li>定义子类</li>
<li>重写接口中的方法</li>
<li>创建子类对象</li>
<li>调用重写后的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义接口的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 重写抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗刨式...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 创建实现类对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">// 4. 调用方法</span></span><br><span class="line">        s.swimming();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。</p>
<h3 id="3-9-3-匿名内部类前提和格式"><a href="#3-9-3-匿名内部类前提和格式" class="headerlink" title="3.9.3 匿名内部类前提和格式"></a>3.9.3 匿名内部类前提和格式</h3><p>匿名内部类必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong>。</p>
<p><strong>匿名内部类格式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类名或者接口名()&#123;</span><br><span class="line">    <span class="comment">// 方法重写</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="3-9-4-使用方式"><a href="#3-9-4-使用方式" class="headerlink" title="3.9.4 使用方式"></a>3.9.4 使用方式</h3><p>以接口为例，匿名内部类的使用，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用匿名内部类</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;自由泳...&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.swimming();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接口 变量 = new 实现类(); // 多态,走子类的重写方法</span></span><br><span class="line">        <span class="type">Swim</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;蛙泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        s2.swimming();</span><br><span class="line">        s2.swimming();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/post/cd36ea51/image-20231126165113479-170124144611826.png" class="" title="image-20231126165113479"> 







<h3 id="3-9-5-匿名内部类的特点"><a href="#3-9-5-匿名内部类的特点" class="headerlink" title="3.9.5 匿名内部类的特点"></a>3.9.5 匿名内部类的特点</h3><ol>
<li>定义一个没有名字的内部类</li>
<li>这个类实现了父类，或者父类接口</li>
<li>匿名内部类会创建这个没有名字的类的对象</li>
</ol>
<h3 id="3-9-6-匿名内部类的使用场景"><a href="#3-9-6-匿名内部类的使用场景" class="headerlink" title="3.9.6 匿名内部类的使用场景"></a>3.9.6 匿名内部类的使用场景</h3><p>通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 普通方式传入对象</span></span><br><span class="line">        <span class="comment">// 创建实现类对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        </span><br><span class="line">        goSwimming(s);</span><br><span class="line">        <span class="comment">// 匿名内部类使用场景:作为方法参数传递</span></span><br><span class="line">        <span class="type">Swim</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;蝶泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 传入匿名内部类</span></span><br><span class="line">        goSwimming(s3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完美方案: 一步到位</span></span><br><span class="line">        goSwimming(<span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;大学生, 蛙泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        goSwimming(<span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;小学生, 自由泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个方法,模拟请一些人去游泳</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">goSwimming</span><span class="params">(Swim s)</span> &#123;</span><br><span class="line">        s.swimming();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="匿名内部类的小结"><a href="#匿名内部类的小结" class="headerlink" title="匿名内部类的小结"></a>匿名内部类的小结</h3><img src="/post/cd36ea51/image-20231129150624933.png" class="" title="image-20231129150624933">   

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://017328.xyz">下完这场雨</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://017328.xyz/post/cd36ea51.html">https://017328.xyz/post/cd36ea51.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://017328.xyz" target="_blank">cout<<"金缕衣";</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E8%AF%AD%E6%B3%95/">java语法</a></div><div class="post_share"><div class="social-share" data-image="/img/beauty15.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wx.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wx.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/zfb.jpg" target="_blank"><img class="post-qr-code-img" src="/img/zfb.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/e18d58c5.html" title="Qt入门"><img class="cover" src="/img/beauty9.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Qt入门</div></div></a></div><div class="next-post pull-right"><a href="/post/c6b8c88d.html" title="C++泛型编程和STL"><img class="cover" src="/img/beauty7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++泛型编程和STL</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTAyMS8zNTQ4Mw=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/h.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">下完这场雨</div><div class="author-info__description">椿萱并茂，棠棣同馨，松萝共倚，兰桂齐芳。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/666XRB"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/666XRB" target="_blank" title="Github"><i class="fab fa-github" style="color: #8a2be2;"></i></a><a class="social-icon" href="https://blog.csdn.net/xideaha?type=blog" target="_blank" title="CSDN"><i class="fa-solid fa-code" style="color: #8a2be2;"></i></a><a class="social-icon" href="https://www.xiaohongshu.com/user/profile/62da23010000000002001769" target="_blank" title="redbook"><i class="fa-solid fa-book" style="color: #8a2be2;"></i></a><a class="social-icon" href="https://space.bilibili.com/452179119" target="_blank" title="bilibili"><i class="fab fa-bilibili" style="color: #8a2be2;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这里啊，这里是我的blog，分享一些学习知识。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">类&amp;对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.2.</span> <span class="toc-text">权限修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90%E7%9A%84%E8%AE%BF%E9%97%AE%E8%83%BD%E5%8A%9B"><span class="toc-number">1.3.</span> <span class="toc-text">不同权限的访问能力</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFstatic%E2%98%85%E2%98%85"><span class="toc-number">3.</span> <span class="toc-text">&#x3D;&#x3D;继承static★★&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.</span> <span class="toc-text">this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.0.1.</span> <span class="toc-text">this关键字的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E6%99%AE%E9%80%9A%E7%9A%84gettter%E4%B8%8Esetter%E6%96%B9%E6%B3%95"><span class="toc-number">4.0.2.</span> <span class="toc-text">用于普通的gettter与setter方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Static%E5%85%B3%E9%94%AE%E5%AD%97-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">5.</span> <span class="toc-text">Static关键字 &amp;内存区域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-static%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">2.1 static概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">2.2 定义格式和使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">5.3.</span> <span class="toc-text">2.3静态成员的访问方式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86"><span class="toc-number">5.4.</span> <span class="toc-text">2.4内存区域划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5static%E5%86%85%E5%AD%98%E5%9B%BE%E8%A7%A3%E9%87%8A"><span class="toc-number">5.5.</span> <span class="toc-text">2.5static内存图解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.6.</span> <span class="toc-text">static的注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%B0%8F%E7%BB%93"><span class="toc-number">5.7.</span> <span class="toc-text">2.5&#x3D;&#x3D;小结&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">6.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">3.1 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E5%BC%95%E5%85%A5"><span class="toc-number">6.1.1.</span> <span class="toc-text">3.1.1 引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">6.1.2.</span> <span class="toc-text">3.1.2 继承的含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">6.1.3.</span> <span class="toc-text">3.1.3 继承的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">3.2 继承的格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%BB%A7%E6%89%BF%E6%A1%88%E4%BE%8B"><span class="toc-number">6.3.</span> <span class="toc-text">3.3 继承案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E6%A1%88%E4%BE%8B"><span class="toc-number">6.3.1.</span> <span class="toc-text">3.3.1 案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E6%A1%88%E4%BE%8B%E5%9B%BE%E8%A7%A3%E5%88%86%E6%9E%90"><span class="toc-number">6.3.2.</span> <span class="toc-text">3.3.2 案例图解分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.3.3.</span> <span class="toc-text">3.3.3 案例代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-4-%E5%B0%8F%E7%BB%93"><span class="toc-number">6.3.4.</span> <span class="toc-text">3.3.4 &#x3D;&#x3D;小结&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%AD%90%E7%B1%BB%E4%B8%8D%E8%83%BD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">6.4.</span> <span class="toc-text">3.4 &#x3D;&#x3D;子类不能继承的内容&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E5%BC%95%E5%85%A5"><span class="toc-number">6.4.1.</span> <span class="toc-text">3.4.1 引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E6%BC%94%E7%A4%BA%E4%BB%A3%E7%A0%81"><span class="toc-number">6.4.2.</span> <span class="toc-text">3.4.1 演示代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="toc-number">6.5.</span> <span class="toc-text">&#x3D;&#x3D;虚方法表&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="toc-number">6.5.1.</span> <span class="toc-text">问题引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9B%BE%E5%88%86%E6%9E%90"><span class="toc-number">6.5.2.</span> <span class="toc-text">内存图分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.5.3.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">6.6.</span> <span class="toc-text">继承中成员的访问特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#super%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.6.1.</span> <span class="toc-text">super使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E7%BB%A7%E6%89%BF%E5%90%8E%E7%9A%84%E7%89%B9%E7%82%B9%E2%80%94%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">6.7.</span> <span class="toc-text">3.5 继承后的特点—成员变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8D%E9%87%8D%E5%90%8D"><span class="toc-number">6.7.1.</span> <span class="toc-text">3.5.1 成员变量不重名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E9%87%8D%E5%90%8D"><span class="toc-number">6.7.2.</span> <span class="toc-text">3.5.2 成员变量重名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-super%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">6.7.3.</span> <span class="toc-text">3.5.3  super访问父类成员变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E7%BB%A7%E6%89%BF%E5%90%8E%E7%9A%84%E7%89%B9%E7%82%B9%E2%80%94%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">6.8.</span> <span class="toc-text">3.6 继承后的特点—成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E4%B8%8D%E9%87%8D%E5%90%8D"><span class="toc-number">6.8.1.</span> <span class="toc-text">3.6.1 成员方法不重名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E9%87%8D%E5%90%8D"><span class="toc-number">6.8.2.</span> <span class="toc-text">3.6.2 成员方法重名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">6.9.</span> <span class="toc-text">3.7 方法重写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">6.9.1.</span> <span class="toc-text">3.7.1 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%A1%88%E4%BE%8B"><span class="toc-number">6.9.2.</span> <span class="toc-text">3.7.2 使用场景与案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2-Override%E9%87%8D%E5%86%99%E6%B3%A8%E8%A7%A3"><span class="toc-number">6.9.3.</span> <span class="toc-text">3.7.2 @Override重写注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.9.4.</span> <span class="toc-text">3.7.3 &#x3D;&#x3D;注意事项&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E7%BB%A7%E6%89%BF%E5%90%8E%E7%9A%84%E7%89%B9%E7%82%B9%E2%80%94%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">6.10.</span> <span class="toc-text">3.8 继承后的特点—构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-1-%E5%BC%95%E5%85%A5"><span class="toc-number">6.10.1.</span> <span class="toc-text">3.8.1 引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-2-%E6%A1%88%E4%BE%8B"><span class="toc-number">6.10.2.</span> <span class="toc-text">3.8.2 案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-3-%E5%B0%8F%E7%BB%93"><span class="toc-number">6.10.3.</span> <span class="toc-text">3.8.3 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-super-%E2%80%A6-%E5%92%8Cthis-%E2%80%A6"><span class="toc-number">6.11.</span> <span class="toc-text">3.9 super(…)和this(…)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-1-%E5%BC%95%E5%85%A5"><span class="toc-number">6.11.1.</span> <span class="toc-text">3.9.1  引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-2-super%E5%92%8Cthis%E7%9A%84%E7%94%A8%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.11.2.</span> <span class="toc-text">3.9.2 super和this的用法格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-3-super-%E2%80%A6-%E7%94%A8%E6%B3%95%E6%BC%94%E7%A4%BA"><span class="toc-number">6.11.3.</span> <span class="toc-text">3.9.3 super(….)用法演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-4-super-%E2%80%A6-%E6%A1%88%E4%BE%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">6.11.4.</span> <span class="toc-text">3.9.4 super(…)案例图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-5-this-%E2%80%A6-%E7%94%A8%E6%B3%95%E6%BC%94%E7%A4%BA"><span class="toc-number">6.11.5.</span> <span class="toc-text">3.9.5 this(…)用法演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-6-%E5%B0%8F%E7%BB%93"><span class="toc-number">6.11.6.</span> <span class="toc-text">3.9.6 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">6.12.</span> <span class="toc-text">3.10 继承的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B%EF%BC%9A"><span class="toc-number">6.13.</span> <span class="toc-text">测试案例：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%8C%85final%E2%98%85%E2%98%85"><span class="toc-number">7.</span> <span class="toc-text">&#x3D;&#x3D;多态包final★★&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">8.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">最简单的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%A4%9A%E6%80%81%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">1.1 多态的形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.3.</span> <span class="toc-text">1.2 多态的使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%89%8D%E6%8F%90"><span class="toc-number">8.4.</span> <span class="toc-text">1.3 多态的定义和前提</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%A4%9A%E6%80%81%E7%9A%84%E8%BF%90%E8%A1%8C%E7%89%B9%E7%82%B9"><span class="toc-number">8.5.</span> <span class="toc-text">1.4 多态的运行特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E9%87%8A"><span class="toc-number">8.6.</span> <span class="toc-text">多态的内存解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%A4%9A%E6%80%81%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">8.7.</span> <span class="toc-text">1.5 多态的弊端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.8.</span> <span class="toc-text">instanceof关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.9.</span> <span class="toc-text">1.6 引用类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BD%AC%E5%9E%8B"><span class="toc-number">8.9.1.</span> <span class="toc-text">1.6.1 为什么要转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-2-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%88%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-number">8.9.2.</span> <span class="toc-text">1.6.2 向上转型（自动转换）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B-%EF%BC%88%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-number">8.9.3.</span> <span class="toc-text">1.6&#x3D;&#x3D;向下转型&#x3D;&#x3D;（强制转换）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-4-%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">8.9.4.</span> <span class="toc-text">1.6.4 案例演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-5-%E8%BD%AC%E5%9E%8B%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">8.9.5.</span> <span class="toc-text">1.6.5 转型的异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-6-instanceof%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.9.6.</span> <span class="toc-text">1.6.6 instanceof关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-7-instanceof%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">8.9.7.</span> <span class="toc-text">1.6.7 instanceof新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0"><span class="toc-number">8.9.8.</span> <span class="toc-text">1.7 综合练习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">9.</span> <span class="toc-text">包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">9.1.</span> <span class="toc-text">包的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%8C%85"><span class="toc-number">9.2.</span> <span class="toc-text">2.1 包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%AF%BC%E5%8C%85"><span class="toc-number">9.3.</span> <span class="toc-text">2.2 导包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E5%8C%85%E4%B8%8B%E7%9A%84%E7%9B%B8%E5%90%8C%E7%B1%BB%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E3%80%81"><span class="toc-number">9.4.</span> <span class="toc-text">2.3 使用不同包下的相同类怎么办？、</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6-1"><span class="toc-number">10.</span> <span class="toc-text">权限修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">10.1.</span> <span class="toc-text">3.1 权限修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90%E7%9A%84%E8%AE%BF%E9%97%AE%E8%83%BD%E5%8A%9B"><span class="toc-number">10.2.</span> <span class="toc-text">3.2 不同权限的访问能力</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">11.</span> <span class="toc-text">final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">11.1.</span> <span class="toc-text">4.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">11.2.</span> <span class="toc-text">4.2 使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-number">11.2.1.</span> <span class="toc-text">4.2.1 修饰类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.2.</span> <span class="toc-text">4.2.2 修饰方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">11.2.3.</span> <span class="toc-text">4.2.3 修饰变量-局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">11.2.4.</span> <span class="toc-text">4.2.4 修饰变量-成员变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93"><span class="toc-number">11.3.</span> <span class="toc-text">final关键字总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8E%A5%E5%8F%A3-%E5%86%85%E9%83%A8%E7%B1%BB%E2%98%85%E2%98%85%E2%98%85"><span class="toc-number">12.</span> <span class="toc-text">&#x3D;&#x3D;抽象类&amp;接口&amp;内部类★★★&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">13.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">13.1.</span> <span class="toc-text">1.1 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%BC%95%E5%85%A5"><span class="toc-number">13.1.1.</span> <span class="toc-text">1.1.1 抽象类引入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-abstract%E4%BD%BF%E7%94%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">13.2.</span> <span class="toc-text">1.2 abstract使用格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.1.</span> <span class="toc-text">1.2.1 抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">13.2.2.</span> <span class="toc-text">1.2.2 抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">13.2.3.</span> <span class="toc-text">1.2.3 抽象类的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">13.3.</span> <span class="toc-text">1.3 抽象类的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">13.4.</span> <span class="toc-text">1.4 抽象类的细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">13.5.</span> <span class="toc-text">1.5 抽象类存在的意义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">14.1.</span> <span class="toc-text">2.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F"><span class="toc-number">14.2.</span> <span class="toc-text">2.2 定义格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%8E%A5%E5%8F%A3%E6%88%90%E5%88%86%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">14.3.</span> <span class="toc-text">&#x3D;&#x3D;2.3 接口成分的特点&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">14.3.1.</span> <span class="toc-text">2.3.1.抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%B8%B8%E9%87%8F"><span class="toc-number">14.3.2.</span> <span class="toc-text">2.3.2 常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">14.3.3.</span> <span class="toc-text">2.3.3 案例演示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#default%EF%BC%8Cstatic%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">14.4.</span> <span class="toc-text">default，static关键字，私有方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Default"><span class="toc-number">14.4.1.</span> <span class="toc-text">Default</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E6%96%B9%E6%B3%95"><span class="toc-number">14.4.2.</span> <span class="toc-text">static方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">14.4.3.</span> <span class="toc-text">私有方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84-%E5%85%B3%E7%B3%BB"><span class="toc-number">14.5.</span> <span class="toc-text">接口和类之间的 关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">14.6.</span> <span class="toc-text">2.4 基本的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3-%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">14.6.1.</span> <span class="toc-text">2.4.1 &#x3D;&#x3D;实现接口&#x3D;&#x3D;的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">14.6.2.</span> <span class="toc-text">2.4.2 实现接口的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%A6%81%E6%B1%82%E5%92%8C%E6%84%8F%E4%B9%89"><span class="toc-number">14.6.3.</span> <span class="toc-text">2.4.3 类实现接口的要求和意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B"><span class="toc-number">14.6.4.</span> <span class="toc-text">2.4.4  类与接口基本实现案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-5-%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84-%E5%A4%9A%E5%AE%9E%E7%8E%B0-%E6%A1%88%E4%BE%8B"><span class="toc-number">14.6.5.</span> <span class="toc-text">2.4.5 类与接口的&#x3D;&#x3D;多实现&#x3D;&#x3D;案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">14.7.</span> <span class="toc-text">2.5 接口与接口的多继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6%E6%89%A9%E5%B1%95%EF%BC%9A%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">14.8.</span> <span class="toc-text">2.6扩展：接口的细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">14.9.</span> <span class="toc-text">适配器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%80%BB%E7%BB%93"><span class="toc-number">14.10.</span> <span class="toc-text">接口总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">15.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B"><span class="toc-number">15.1.</span> <span class="toc-text">3.1 快速上手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">15.1.1.</span> <span class="toc-text">3.1.1 什么是内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">15.1.2.</span> <span class="toc-text">3.1.2 什么时候使用内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">15.2.</span> <span class="toc-text">3.2 内部类的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">15.3.</span> <span class="toc-text">3.3 成员内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">15.4.</span> <span class="toc-text">3.4 成员内部类的细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">15.5.</span> <span class="toc-text">3.5 成员内部类面试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">15.6.</span> <span class="toc-text">3.6 成员内部类内存图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">15.7.</span> <span class="toc-text">3.7 静态内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">15.8.</span> <span class="toc-text">3.8 局部内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91"><span class="toc-number">15.9.</span> <span class="toc-text">3.9 &#x3D;&#x3D;匿名内部类【重点】&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">15.9.1.</span> <span class="toc-text">3.9.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-2-%E6%A0%BC%E5%BC%8F"><span class="toc-number">15.9.2.</span> <span class="toc-text">3.9.2 格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91javap-class%E6%96%87%E4%BB%B6"><span class="toc-number">15.9.3.</span> <span class="toc-text">&#x3D;&#x3D;反编译javap .class文件&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-2-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%88%B0%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">15.9.4.</span> <span class="toc-text">3.9.2 什么时候用到匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-3-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%89%8D%E6%8F%90%E5%92%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">15.9.5.</span> <span class="toc-text">3.9.3 匿名内部类前提和格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-4-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">15.9.6.</span> <span class="toc-text">3.9.4 使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-5-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">15.9.7.</span> <span class="toc-text">3.9.5 匿名内部类的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-6-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">15.9.8.</span> <span class="toc-text">3.9.6 匿名内部类的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%B0%8F%E7%BB%93"><span class="toc-number">15.9.9.</span> <span class="toc-text">匿名内部类的小结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/4d9ab4ed.html" title="github图床"><img src="/img/b11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="github图床"/></a><div class="content"><a class="title" href="/post/4d9ab4ed.html" title="github图床">github图床</a><time datetime="2025-09-24T16:00:00.000Z" title="发表于 2025-09-25 00:00:00">2025-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/b34cc72c.html" title="逻辑论证1（削弱）"><img src="/img/g10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="逻辑论证1（削弱）"/></a><div class="content"><a class="title" href="/post/b34cc72c.html" title="逻辑论证1（削弱）">逻辑论证1（削弱）</a><time datetime="2025-03-27T11:21:42.000Z" title="发表于 2025-03-27 19:21:42">2025-03-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/dbde71d8.html" title="组合排列"><img src="/img/g9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="组合排列"/></a><div class="content"><a class="title" href="/post/dbde71d8.html" title="组合排列">组合排列</a><time datetime="2025-03-26T01:18:37.000Z" title="发表于 2025-03-26 09:18:37">2025-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d9a2d074.html" title="翻译推理"><img src="/img/g8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="翻译推理"/></a><div class="content"><a class="title" href="/post/d9a2d074.html" title="翻译推理">翻译推理</a><time datetime="2025-03-25T01:30:22.000Z" title="发表于 2025-03-25 09:30:22">2025-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/ef3d0435.html" title="判断推理_定义判断"><img src="/img/g7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="判断推理_定义判断"/></a><div class="content"><a class="title" href="/post/ef3d0435.html" title="判断推理_定义判断">判断推理_定义判断</a><time datetime="2025-03-19T11:12:43.000Z" title="发表于 2025-03-19 19:12:43">2025-03-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text"><style>
  .footer {
    text-align: center;
    position: relative;
  }
  .social-links {
    display: flex;
    justify-content: center;
    gap: 1.5rem;
    flex-wrap: wrap;
  }
  .social-links i {
    color: #8400ff;
  }
  .social-link {
    color: #8a2be2;
    font-size: 1.2rem;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 2.5rem;
    height: 2.5rem;
    border-radius: 50%;
    background: rgba(138, 43, 226, 0.1);
  }
  .social-link:hover {
    color: #892be294;
    background: #892be294;
    transform: translateY(-3px) scale(1.2);
    box-shadow: 0 5px 15px rgba(138, 43, 226, 0.4);
    text-decoration: none !important; 
  }
  .footer p {
    margin: 0.5rem 0;
    line-height: 1;
  }
  .copyright {
    font-size: 1.1rem; 
    color: #c08bdf;
    font-weight: 400;
  }
  .tagline {
    font-size: 0.8rem;
    color: #8a2be2;
    font-style: italic;
    font-weight: 500;
  }
  .visitor-count {
    font-size: 0.75rem;
    color: rgba(219, 142, 255, 0.658);
    font-weight: 300;
  }
  #visitorCount {
    font-weight: bold;
  }
  .icp-info {
    margin-top: 0.8rem;
    font-size: 1.1rem; /* 增大字体大小 */
  }
  .icp-link {
    color: #1e90ff; /* 更明亮的蓝色，确保在白天主题下清晰可见 */
    text-decoration: none;
    font-weight: 500; /* 增加字体粗细 */
  }
  .icp-link:hover {
    color: #0066cc; /* 悬停时颜色稍微加深 */
  }
</style>
<div class="footer">
  <div class="social-links">
    <a href="https://github.com/666XRB" class="social-link" target="_blank" rel="noopener noreferrer" aria-label="GitHub" title="GitHub">
      <i class="fab fa-github"></i>
    </a>
    <a href="https://blog.csdn.net/xideaha?type=blog" class="social-link" target="_blank" rel="noopener noreferrer" aria-label="CSDN" title="CSDN">
      <i class="fas fa-code"></i>
    </a>
    <a href="https://www.xiaohongshu.com/user/profile/62da23010000000002001769" class="social-link" target="_blank" rel="noopener noreferrer" aria-label="小红书" title="小红书">
      <i class="fas fa-book"></i>
    </a>
    <a href="https://space.bilibili.com/452179119" class="social-link" target="_blank" rel="noopener noreferrer" aria-label="bilibili" title="bilibili">
      <i class="fab fa-bilibili"></i>
    </a>
  </div>
  <p class="copyright">© 2025 下完这场雨 - 所有权利保留</p>
  <p class="tagline">> Stay curious, stay hacking, stay anime! <</p>
  <p class="visitor-count">访问量: <span id="visitorCount">1024</span> | 你是第 <span id="dailyVisitor">1</span> 位今日访客</p>
  <p class="icp-info">
    <a href="https://beian.miit.gov.cn/#/Integrated/index" class="icp-link" target="_blank">豫ICP备2024090942号-1</a>
  </p>
</div>

<script>
  // 确保DOM加载完成后执行
  document.addEventListener('DOMContentLoaded', function() {
    
    // 模拟访问量增长
    function updateVisitorCount() {
      const countElement = document.getElementById('visitorCount');
      let count = parseInt(countElement.textContent) || 1024;
      
      // 从localStorage获取或初始化计数
      const storedCount = localStorage.getItem('totalVisitors');
      if (storedCount) {
        count = parseInt(storedCount);
        countElement.textContent = count;
      }
      
      // 每日访客计数
      const today = new Date().toDateString();
      const dailyData = JSON.parse(localStorage.getItem('dailyVisitors') || '{"date":"", "count":0}');
      if (dailyData.date !== today) {
        dailyData.date = today;
        dailyData.count = 0;
      }
      dailyData.count += 1;
      document.getElementById('dailyVisitor').textContent = dailyData.count;
      localStorage.setItem('dailyVisitors', JSON.stringify(dailyData));
      
      // 每30秒随机增加访问量
      setInterval(() => {
        count += Math.floor(Math.random() * 3);
        countElement.textContent = count;
        localStorage.setItem('totalVisitors', count.toString());
      }, 30000);
    }
    
    updateVisitorCount();
    
    // 添加点击动画效果
    const socialLinks = document.querySelectorAll('.social-link');
    socialLinks.forEach(link => {
      link.addEventListener('click', function() {
        this.style.transform = 'scale(0.9)';
        setTimeout(() => {
          this.style.transform = '';
        }, 300);
      });
    });
  });
</script>
</div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'VbfV1mFYBGUNtUKD0cr1qUls-gzGzoHsz',
      appKey: 'LssvKROPsftMFNCa4j2AnVL8',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Valine' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://VbfV1mFY.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'VbfV1mFYBGUNtUKD0cr1qUls-gzGzoHsz',
        "X-LC-Key": 'LssvKROPsftMFNCa4j2AnVL8',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="592262222" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="false" muted></div><script src="http://cdn.bootcss.com/pace/1.0.2/pace.min.js" async></script><script src="/js/weather.js"></script><script src="https://jsd.onmicrosoft.cn/gh/wuuconix/live2d-cdn@v0.1.8/autoload.js"></script><script defer src="/js/cursor.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="random" async="async"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>